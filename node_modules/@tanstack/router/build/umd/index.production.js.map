{"version":3,"file":"index.production.js","sources":["../../../../node_modules/.pnpm/tiny-invariant@1.3.1/node_modules/tiny-invariant/dist/esm/tiny-invariant.js","../../src/history.ts","../../src/utils.ts","../../src/path.ts","../../src/qss.ts","../../src/route.ts","../../../store/build/esm/index.js","../../src/searchParams.ts","../../src/router.ts","../../src/routeMatch.ts","../../../../node_modules/.pnpm/tiny-warning@1.0.3/node_modules/tiny-warning/dist/tiny-warning.esm.js"],"sourcesContent":["var isProduction = process.env.NODE_ENV === 'production';\nvar prefix = 'Invariant failed';\nfunction invariant(condition, message) {\n    if (condition) {\n        return;\n    }\n    if (isProduction) {\n        throw new Error(prefix);\n    }\n    var provided = typeof message === 'function' ? message() : message;\n    var value = provided ? \"\".concat(prefix, \": \").concat(provided) : prefix;\n    throw new Error(value);\n}\n\nexport { invariant as default };\n","// While the public API was clearly inspired by the \"history\" npm package,\n// This implementation attempts to be more lightweight by\n// making assumptions about the way TanStack Router works\n\nexport interface RouterHistory {\n  location: RouterLocation\n  listen: (cb: () => void) => () => void\n  push: (path: string, state: any) => void\n  replace: (path: string, state: any) => void\n  go: (index: number) => void\n  back: () => void\n  forward: () => void\n  createHref: (href: string) => string\n  block: (blockerFn: BlockerFn) => () => void\n}\n\nexport interface ParsedPath {\n  href: string\n  pathname: string\n  search: string\n  hash: string\n}\n\nexport interface RouterLocation extends ParsedPath {\n  state: any\n}\n\ntype BlockerFn = (retry: () => void, cancel: () => void) => void\n\nconst popStateEvent = 'popstate'\nconst beforeUnloadEvent = 'beforeunload'\n\nconst beforeUnloadListener = (event: Event) => {\n  event.preventDefault()\n  // @ts-ignore\n  return (event.returnValue = '')\n}\n\nconst stopBlocking = () => {\n  removeEventListener(beforeUnloadEvent, beforeUnloadListener, {\n    capture: true,\n  })\n}\n\nfunction createHistory(opts: {\n  getLocation: () => RouterLocation\n  listener: (onUpdate: () => void) => () => void\n  pushState: (path: string, state: any) => void\n  replaceState: (path: string, state: any) => void\n  go: (n: number) => void\n  back: () => void\n  forward: () => void\n  createHref: (path: string) => string\n}): RouterHistory {\n  let currentLocation = opts.getLocation()\n  let unsub = () => {}\n  let listeners = new Set<() => void>()\n  let blockers: BlockerFn[] = []\n  let queue: (() => void)[] = []\n\n  const tryFlush = () => {\n    if (blockers.length) {\n      blockers[0]?.(tryFlush, () => {\n        blockers = []\n        stopBlocking()\n      })\n      return\n    }\n\n    while (queue.length) {\n      queue.shift()?.()\n    }\n\n    onUpdate()\n  }\n\n  const queueTask = (task: () => void) => {\n    queue.push(task)\n    tryFlush()\n  }\n\n  const onUpdate = () => {\n    currentLocation = opts.getLocation()\n    listeners.forEach((listener) => listener())\n  }\n\n  return {\n    get location() {\n      return currentLocation\n    },\n    listen: (cb: () => void) => {\n      if (listeners.size === 0) {\n        unsub = opts.listener(onUpdate)\n      }\n      listeners.add(cb)\n\n      return () => {\n        listeners.delete(cb)\n        if (listeners.size === 0) {\n          unsub()\n        }\n      }\n    },\n    push: (path: string, state: any) => {\n      queueTask(() => {\n        opts.pushState(path, state)\n      })\n    },\n    replace: (path: string, state: any) => {\n      queueTask(() => {\n        opts.replaceState(path, state)\n      })\n    },\n    go: (index) => {\n      queueTask(() => {\n        opts.go(index)\n      })\n    },\n    back: () => {\n      queueTask(() => {\n        opts.back()\n      })\n    },\n    forward: () => {\n      queueTask(() => {\n        opts.forward()\n      })\n    },\n    createHref: (str) => opts.createHref(str),\n    block: (cb) => {\n      blockers.push(cb)\n\n      if (blockers.length === 1) {\n        addEventListener(beforeUnloadEvent, beforeUnloadListener, {\n          capture: true,\n        })\n      }\n\n      return () => {\n        blockers = blockers.filter((b) => b !== cb)\n\n        if (!blockers.length) {\n          stopBlocking()\n        }\n      }\n    },\n  }\n}\n\nexport function createBrowserHistory(opts?: {\n  getHref?: () => string\n  createHref?: (path: string) => string\n}): RouterHistory {\n  const getHref =\n    opts?.getHref ??\n    (() =>\n      `${window.location.pathname}${window.location.hash}${window.location.search}`)\n  const createHref = opts?.createHref ?? ((path) => path)\n  const getLocation = () => parseLocation(getHref(), history.state)\n\n  return createHistory({\n    getLocation,\n    listener: (onUpdate) => {\n      window.addEventListener(popStateEvent, onUpdate)\n      return () => {\n        window.removeEventListener(popStateEvent, onUpdate)\n      }\n    },\n    pushState: (path, state) => {\n      window.history.pushState(\n        { ...state, key: createRandomKey() },\n        '',\n        createHref(path),\n      )\n    },\n    replaceState: (path, state) => {\n      window.history.replaceState(\n        { ...state, key: createRandomKey() },\n        '',\n        createHref(path),\n      )\n    },\n    back: () => window.history.back(),\n    forward: () => window.history.forward(),\n    go: (n) => window.history.go(n),\n    createHref: (path) => createHref(path),\n  })\n}\n\nexport function createHashHistory(): RouterHistory {\n  return createBrowserHistory({\n    getHref: () => window.location.hash.substring(1),\n    createHref: (path) => `#${path}`,\n  })\n}\n\nexport function createMemoryHistory(\n  opts: {\n    initialEntries: string[]\n    initialIndex?: number\n  } = {\n    initialEntries: ['/'],\n  },\n): RouterHistory {\n  const entries = opts.initialEntries\n  let index = opts.initialIndex ?? entries.length - 1\n  let currentState = {}\n\n  const getLocation = () => parseLocation(entries[index]!, currentState)\n\n  return createHistory({\n    getLocation,\n    listener: () => {\n      return () => {}\n    },\n    pushState: (path, state) => {\n      currentState = {\n        ...state,\n        key: createRandomKey(),\n      }\n      entries.push(path)\n      index++\n    },\n    replaceState: (path, state) => {\n      currentState = {\n        ...state,\n        key: createRandomKey(),\n      }\n      entries[index] = path\n    },\n    back: () => {\n      index--\n    },\n    forward: () => {\n      index = Math.min(index + 1, entries.length - 1)\n    },\n    go: (n) => window.history.go(n),\n    createHref: (path) => path,\n  })\n}\n\nfunction parseLocation(href: string, state: any): RouterLocation {\n  let hashIndex = href.indexOf('#')\n  let searchIndex = href.indexOf('?')\n\n  return {\n    href,\n    pathname: href.substring(\n      0,\n      hashIndex > 0\n        ? searchIndex > 0\n          ? Math.min(hashIndex, searchIndex)\n          : hashIndex\n        : searchIndex > 0\n        ? searchIndex\n        : href.length,\n    ),\n    hash: hashIndex > -1 ? href.substring(hashIndex, searchIndex) : '',\n    search: searchIndex > -1 ? href.substring(searchIndex) : '',\n    state,\n  }\n}\n\n// Thanks co-pilot!\nfunction createRandomKey() {\n  return (Math.random() + 1).toString(36).substring(7)\n}\n","export type NoInfer<T> = [T][T extends any ? 0 : never]\nexport type IsAny<T, Y, N> = 1 extends 0 & T ? Y : N\nexport type IsAnyBoolean<T> = 1 extends 0 & T ? true : false\nexport type IsKnown<T, Y, N> = unknown extends T ? N : Y\nexport type PickAsRequired<T, K extends keyof T> = Omit<T, K> &\n  Required<Pick<T, K>>\nexport type PickAsPartial<T, K extends keyof T> = Omit<T, K> &\n  Partial<Pick<T, K>>\nexport type PickUnsafe<T, K> = K extends keyof T ? Pick<T, K> : never\nexport type PickExtra<T, K> = {\n  [TKey in keyof K as string extends TKey\n    ? never\n    : TKey extends keyof T\n    ? never\n    : TKey]: K[TKey]\n}\n\nexport type PickRequired<T> = {\n  [K in keyof T as undefined extends T[K] ? never : K]: T[K]\n}\n\nexport type Expand<T> = T extends object\n  ? T extends infer O\n    ? { [K in keyof O]: O[K] }\n    : never\n  : T\n\nexport type UnionToIntersection<U> = (\n  U extends any ? (k: U) => void : never\n) extends (k: infer I) => any\n  ? I\n  : never\n\ntype Compute<T> = { [K in keyof T]: T[K] } | never\n\ntype AllKeys<T> = T extends any ? keyof T : never\n\nexport type MergeUnion<T, Keys extends keyof T = keyof T> = Compute<\n  {\n    [K in Keys]: T[Keys]\n  } & {\n    [K in AllKeys<T>]?: T extends any\n      ? K extends keyof T\n        ? T[K]\n        : never\n      : never\n  }\n>\n\nexport type Values<O> = O[ValueKeys<O>]\nexport type ValueKeys<O> = Extract<keyof O, PropertyKey>\n\nexport type DeepAwaited<T> = T extends Promise<infer A>\n  ? DeepAwaited<A>\n  : T extends Record<infer A, Promise<infer B>>\n  ? { [K in A]: DeepAwaited<B> }\n  : T\n\nexport type PathParamMask<TRoutePath extends string> =\n  TRoutePath extends `${infer L}/$${infer C}/${infer R}`\n    ? PathParamMask<`${L}/${string}/${R}`>\n    : TRoutePath extends `${infer L}/$${infer C}`\n    ? PathParamMask<`${L}/${string}`>\n    : TRoutePath\n\nexport type Timeout = ReturnType<typeof setTimeout>\n\nexport type Updater<TPrevious, TResult = TPrevious> =\n  | TResult\n  | ((prev?: TPrevious) => TResult)\n\nexport type PickExtract<T, U> = {\n  [K in keyof T as T[K] extends U ? K : never]: T[K]\n}\n\nexport type PickExclude<T, U> = {\n  [K in keyof T as T[K] extends U ? never : K]: T[K]\n}\n\nexport function last<T>(arr: T[]) {\n  return arr[arr.length - 1]\n}\n\nfunction isFunction(d: any): d is Function {\n  return typeof d === 'function'\n}\n\nexport function functionalUpdate<TResult>(\n  updater: Updater<TResult>,\n  previous: TResult,\n) {\n  if (isFunction(updater)) {\n    return updater(previous as TResult)\n  }\n\n  return updater\n}\n\nexport function pick<T, K extends keyof T>(parent: T, keys: K[]): Pick<T, K> {\n  return keys.reduce((obj: any, key: K) => {\n    obj[key] = parent[key]\n    return obj\n  }, {} as any)\n}\n\n/**\n * This function returns `a` if `b` is deeply equal.\n * If not, it will replace any deeply equal children of `b` with those of `a`.\n * This can be used for structural sharing between immutable JSON values for example.\n * Do not use this with signals\n */\nexport function replaceEqualDeep<T>(prev: any, _next: T): T {\n  if (prev === _next) {\n    return prev\n  }\n\n  const next = _next as any\n\n  const array = Array.isArray(prev) && Array.isArray(next)\n\n  if (array || (isPlainObject(prev) && isPlainObject(next))) {\n    const prevSize = array ? prev.length : Object.keys(prev).length\n    const nextItems = array ? next : Object.keys(next)\n    const nextSize = nextItems.length\n    const copy: any = array ? [] : {}\n\n    let equalItems = 0\n\n    for (let i = 0; i < nextSize; i++) {\n      const key = array ? i : nextItems[i]\n      copy[key] = replaceEqualDeep(prev[key], next[key])\n      if (copy[key] === prev[key]) {\n        equalItems++\n      }\n    }\n\n    return prevSize === nextSize && equalItems === prevSize ? prev : copy\n  }\n\n  return next\n}\n\n// Copied from: https://github.com/jonschlinkert/is-plain-object\nexport function isPlainObject(o: any) {\n  if (!hasObjectPrototype(o)) {\n    return false\n  }\n\n  // If has modified constructor\n  const ctor = o.constructor\n  if (typeof ctor === 'undefined') {\n    return true\n  }\n\n  // If has modified prototype\n  const prot = ctor.prototype\n  if (!hasObjectPrototype(prot)) {\n    return false\n  }\n\n  // If constructor does not have an Object-specific method\n  if (!prot.hasOwnProperty('isPrototypeOf')) {\n    return false\n  }\n\n  // Most likely a plain Object\n  return true\n}\n\nfunction hasObjectPrototype(o: any) {\n  return Object.prototype.toString.call(o) === '[object Object]'\n}\n\nexport function partialDeepEqual(a: any, b: any): boolean {\n  if (a === b) {\n    return true\n  }\n\n  if (typeof a !== typeof b) {\n    return false\n  }\n\n  if (isPlainObject(a) && isPlainObject(b)) {\n    return !Object.keys(b).some((key) => !partialDeepEqual(a[key], b[key]))\n  }\n\n  if (Array.isArray(a) && Array.isArray(b)) {\n    return (\n      a.length === b.length &&\n      a.every((item, index) => partialDeepEqual(item, b[index]))\n    )\n  }\n\n  return false\n}\n","import invariant from 'tiny-invariant'\nimport { AnyPathParams } from './route'\nimport { MatchLocation } from './router'\nimport { last } from './utils'\n\nexport interface Segment {\n  type: 'pathname' | 'param' | 'wildcard'\n  value: string\n}\n\nexport function joinPaths(paths: (string | undefined)[]) {\n  return cleanPath(paths.filter(Boolean).join('/'))\n}\n\nexport function cleanPath(path: string) {\n  // remove double slashes\n  return path.replace(/\\/{2,}/g, '/')\n}\n\nexport function trimPathLeft(path: string) {\n  return path === '/' ? path : path.replace(/^\\/{1,}/, '')\n}\n\nexport function trimPathRight(path: string) {\n  return path === '/' ? path : path.replace(/\\/{1,}$/, '')\n}\n\nexport function trimPath(path: string) {\n  return trimPathRight(trimPathLeft(path))\n}\n\nexport function resolvePath(basepath: string, base: string, to: string) {\n  base = base.replace(new RegExp(`^${basepath}`), '/')\n  to = to.replace(new RegExp(`^${basepath}`), '/')\n\n  let baseSegments = parsePathname(base)\n  const toSegments = parsePathname(to)\n\n  toSegments.forEach((toSegment, index) => {\n    if (toSegment.value === '/') {\n      if (!index) {\n        // Leading slash\n        baseSegments = [toSegment]\n      } else if (index === toSegments.length - 1) {\n        // Trailing Slash\n        baseSegments.push(toSegment)\n      } else {\n        // ignore inter-slashes\n      }\n    } else if (toSegment.value === '..') {\n      // Extra trailing slash? pop it off\n      if (baseSegments.length > 1 && last(baseSegments)?.value === '/') {\n        baseSegments.pop()\n      }\n      baseSegments.pop()\n    } else if (toSegment.value === '.') {\n      return\n    } else {\n      baseSegments.push(toSegment)\n    }\n  })\n\n  const joined = joinPaths([basepath, ...baseSegments.map((d) => d.value)])\n\n  return cleanPath(joined)\n}\n\nexport function parsePathname(pathname?: string): Segment[] {\n  if (!pathname) {\n    return []\n  }\n\n  pathname = cleanPath(pathname)\n\n  const segments: Segment[] = []\n\n  if (pathname.slice(0, 1) === '/') {\n    pathname = pathname.substring(1)\n    segments.push({\n      type: 'pathname',\n      value: '/',\n    })\n  }\n\n  if (!pathname) {\n    return segments\n  }\n\n  // Remove empty segments and '.' segments\n  const split = pathname.split('/').filter(Boolean)\n\n  segments.push(\n    ...split.map((part): Segment => {\n      if (part === '$' || part === '*') {\n        return {\n          type: 'wildcard',\n          value: part,\n        }\n      }\n\n      if (part.charAt(0) === '$') {\n        return {\n          type: 'param',\n          value: part,\n        }\n      }\n\n      return {\n        type: 'pathname',\n        value: part,\n      }\n    }),\n  )\n\n  if (pathname.slice(-1) === '/') {\n    pathname = pathname.substring(1)\n    segments.push({\n      type: 'pathname',\n      value: '/',\n    })\n  }\n\n  return segments\n}\n\nexport function interpolatePath(\n  path: string | undefined,\n  params: any,\n  leaveWildcard?: boolean,\n) {\n  const interpolatedPathSegments = parsePathname(path)\n\n  return joinPaths(\n    interpolatedPathSegments.map((segment) => {\n      if (['$', '*'].includes(segment.value) && !leaveWildcard) {\n        return ''\n      }\n\n      if (segment.type === 'param') {\n        return params![segment.value.substring(1)] ?? ''\n      }\n\n      return segment.value\n    }),\n  )\n}\n\nexport function matchPathname(\n  basepath: string,\n  currentPathname: string,\n  matchLocation: Pick<MatchLocation, 'to' | 'fuzzy' | 'caseSensitive'>,\n): AnyPathParams | undefined {\n  const pathParams = matchByPath(basepath, currentPathname, matchLocation)\n  // const searchMatched = matchBySearch(currentLocation.search, matchLocation)\n\n  if (matchLocation.to && !pathParams) {\n    return\n  }\n\n  return pathParams ?? {}\n}\n\nexport function matchByPath(\n  basepath: string,\n  from: string,\n  matchLocation: Pick<MatchLocation, 'to' | 'caseSensitive' | 'fuzzy'>,\n): Record<string, string> | undefined {\n  if (!from.startsWith(basepath)) {\n    return undefined\n  }\n  from = basepath != '/' ? from.substring(basepath.length) : from\n  const baseSegments = parsePathname(from)\n  const to = `${matchLocation.to ?? '$'}`\n  const routeSegments = parsePathname(to)\n\n  if (last(baseSegments)?.value === '/') {\n    baseSegments.pop()\n  }\n\n  const params: Record<string, string> = {}\n\n  let isMatch = (() => {\n    for (\n      let i = 0;\n      i < Math.max(baseSegments.length, routeSegments.length);\n      i++\n    ) {\n      const baseSegment = baseSegments[i]\n      const routeSegment = routeSegments[i]\n\n      const isLastRouteSegment = i === routeSegments.length - 1\n      const isLastBaseSegment = i === baseSegments.length - 1\n\n      if (routeSegment) {\n        if (routeSegment.type === 'wildcard') {\n          if (baseSegment?.value) {\n            params['*'] = joinPaths(baseSegments.slice(i).map((d) => d.value))\n            return true\n          }\n          return false\n        }\n\n        if (routeSegment.type === 'pathname') {\n          if (routeSegment.value === '/' && !baseSegment?.value) {\n            return true\n          }\n\n          if (baseSegment) {\n            if (matchLocation.caseSensitive) {\n              if (routeSegment.value !== baseSegment.value) {\n                return false\n              }\n            } else if (\n              routeSegment.value.toLowerCase() !==\n              baseSegment.value.toLowerCase()\n            ) {\n              return false\n            }\n          }\n        }\n\n        if (!baseSegment) {\n          return false\n        }\n\n        if (routeSegment.type === 'param') {\n          if (baseSegment?.value === '/') {\n            return false\n          }\n          if (baseSegment.value.charAt(0) !== '$') {\n            params[routeSegment.value.substring(1)] = baseSegment.value\n          }\n        }\n      }\n\n      if (isLastRouteSegment && !isLastBaseSegment) {\n        return !!matchLocation.fuzzy\n      }\n    }\n    return true\n  })()\n\n  return isMatch ? (params as Record<string, string>) : undefined\n}\n","// @ts-nocheck\n\n// qss has been slightly modified and inlined here for our use cases (and compression's sake). We've included it as a hard dependency for MIT license attribution.\n\nexport function encode(obj, pfx?: string) {\n  var k,\n    i,\n    tmp,\n    str = ''\n\n  for (k in obj) {\n    if ((tmp = obj[k]) !== void 0) {\n      if (Array.isArray(tmp)) {\n        for (i = 0; i < tmp.length; i++) {\n          str && (str += '&')\n          str += encodeURIComponent(k) + '=' + encodeURIComponent(tmp[i])\n        }\n      } else {\n        str && (str += '&')\n        str += encodeURIComponent(k) + '=' + encodeURIComponent(tmp)\n      }\n    }\n  }\n\n  return (pfx || '') + str\n}\n\nfunction toValue(mix) {\n  if (!mix) return ''\n  var str = decodeURIComponent(mix)\n  if (str === 'false') return false\n  if (str === 'true') return true\n  if (str.charAt(0) === '0') return str\n  return +str * 0 === 0 ? +str : str\n}\n\nexport function decode(str) {\n  var tmp,\n    k,\n    out = {},\n    arr = str.split('&')\n\n  while ((tmp = arr.shift())) {\n    tmp = tmp.split('=')\n    k = tmp.shift()\n    if (out[k] !== void 0) {\n      out[k] = [].concat(out[k], toValue(tmp.shift()))\n    } else {\n      out[k] = toValue(tmp.shift())\n    }\n  }\n\n  return out\n}\n","import { GetFrameworkGeneric } from './frameworks'\nimport { ParsePathParams } from './link'\nimport { RouteMatch } from './routeMatch'\nimport { AnyRouter, Router, RouterContext } from './router'\nimport {\n  IsAny,\n  NoInfer,\n  PickRequired,\n  PickUnsafe,\n  UnionToIntersection,\n} from './utils'\nimport invariant from 'tiny-invariant'\nimport { joinPaths, trimPath, trimPathRight } from './path'\nimport { DefaultRoutesInfo } from './routeInfo'\n\nexport const rootRouteId = '__root__' as const\nexport type RootRouteId = typeof rootRouteId\n\nexport type AnyPathParams = {}\nexport type AnySearchSchema = {}\nexport type AnyContext = {}\nexport interface RouteMeta {}\nexport interface RouteContext {}\n\nexport type RouteOptionsBase<TCustomId, TPath> =\n  | {\n      path: TPath\n    }\n  | {\n      id: TCustomId\n    }\n\nexport type RouteOptionsBaseIntersection<TCustomId, TPath> =\n  UnionToIntersection<RouteOptionsBase<TCustomId, TPath>>\n\nexport interface FrameworkRouteOptions {}\n\nexport type MetaOptions = keyof PickRequired<RouteMeta> extends never\n  ? {\n      meta?: RouteMeta\n    }\n  : {\n      meta: RouteMeta\n    }\n\ntype GetContextFn<\n  TParentRoute,\n  TAllParams,\n  TFullSearchSchema,\n  TParentContext,\n  TAllParentContext,\n  TRouteContext,\n> = (\n  opts: {\n    params: TAllParams\n    search: TFullSearchSchema\n  } & (TParentRoute extends undefined\n    ? {\n        context?: TAllParentContext\n        parentContext?: TParentContext\n      }\n    : {\n        context: TAllParentContext\n        parentContext: TParentContext\n      }),\n) => TRouteContext\n\nexport type ContextOptions<\n  TParentRoute,\n  TAllParams,\n  TFullSearchSchema,\n  TParentContext,\n  TAllParentContext,\n  TRouteContext,\n> = keyof PickRequired<RouteContext> extends never\n  ? {\n      getContext?: GetContextFn<\n        TParentRoute,\n        TAllParams,\n        TFullSearchSchema,\n        TParentContext,\n        TAllParentContext,\n        TRouteContext\n      >\n    }\n  : {\n      getContext: GetContextFn<\n        TParentRoute,\n        TAllParams,\n        TFullSearchSchema,\n        TParentContext,\n        TAllParentContext,\n        TRouteContext\n      >\n    }\n\nexport type RouteOptions<\n  TParentRoute extends AnyRoute = AnyRoute,\n  TCustomId extends string = string,\n  TPath extends string = string,\n  TParentSearchSchema extends {} = {},\n  TSearchSchema extends AnySearchSchema = {},\n  TFullSearchSchema extends AnySearchSchema = TSearchSchema,\n  TParentParams extends AnyPathParams = {},\n  TParams = Record<ParsePathParams<TPath>, string>,\n  TAllParams = TParams,\n  TParentContext extends AnyContext = AnyContext,\n  TAllParentContext extends AnyContext = AnyContext,\n  TRouteContext extends RouteContext = RouteContext,\n  TContext extends AnyContext = TRouteContext,\n> = RouteOptionsBase<TCustomId, TPath> &\n  FrameworkRouteOptions & {\n    getParentRoute: () => TParentRoute\n    // If true, this route will be matched as case-sensitive\n    caseSensitive?: boolean\n    // Filter functions that can manipulate search params *before* they are passed to links and navigate\n    // calls that match this route.\n    preSearchFilters?: SearchFilter<TFullSearchSchema>[]\n    // Filter functions that can manipulate search params *after* they are passed to links and navigate\n    // calls that match this route.\n    postSearchFilters?: SearchFilter<TFullSearchSchema>[]\n    // The content to be rendered when the route is matched. If no component is provided, defaults to `<Outlet />`\n    component?: GetFrameworkGeneric<'Component'> // , NoInfer<TParentAllLoaderData>>\n    // The content to be rendered when the route encounters an error\n    errorComponent?: GetFrameworkGeneric<'ErrorComponent'> // , NoInfer<TParentAllLoaderData>>\n    // If supported by your framework, the content to be rendered as the fallback content until the route is ready to render\n    pendingComponent?: GetFrameworkGeneric<'Component'> //, NoInfer<TParentAllLoaderData>>\n    // This async function is called before a route is loaded.\n    // If an error is thrown here, the route's loader will not be called.\n    // If thrown during a navigation, the navigation will be cancelled and the error will be passed to the `onLoadError` function.\n    // If thrown during a preload event, the error will be logged to the console.\n    beforeLoad?: (opts: {\n      router: AnyRouter\n      match: RouteMatch\n    }) => Promise<void> | void\n    // This function will be called if the route's loader throws an error **during an attempted navigation**.\n    // If you want to redirect due to an error, call `router.navigate()` from within this function.\n    onBeforeLoadError?: (err: any) => void\n    validateSearch?: SearchSchemaValidator<TSearchSchema, TParentSearchSchema>\n    // This function will be called if the route's validateSearch option throws an error **during an attempted validation**.\n    // If you want to redirect due to an error, call `router.navigate()` from within this function.\n    // If you want to display the errorComponent, rethrow the error\n    onValidateSearchError?: (err: any) => void\n    // An asynchronous function responsible for preparing or fetching data for the route before it is rendered\n    onLoad?: OnLoadFn<\n      TSearchSchema,\n      TFullSearchSchema,\n      TAllParams,\n      NoInfer<TRouteContext>,\n      TContext\n    >\n    onLoadError?: (err: any) => void\n    onError?: (err: any) => void\n    // This function is called\n    // when moving from an inactive state to an active one. Likewise, when moving from\n    // an active to an inactive state, the return function (if provided) is called.\n    onLoaded?: (matchContext: {\n      params: TAllParams\n      search: TFullSearchSchema\n    }) =>\n      | void\n      | undefined\n      | ((match: { params: TAllParams; search: TFullSearchSchema }) => void)\n    // This function is called when the route remains active from one transition to the next.\n    onTransition?: (match: {\n      params: TAllParams\n      search: TFullSearchSchema\n    }) => void\n  } & MetaOptions &\n  ContextOptions<\n    TParentRoute,\n    TAllParams,\n    TFullSearchSchema,\n    TParentContext,\n    TAllParentContext,\n    TRouteContext\n  > &\n  (\n    | {\n        // Parse params optionally receives path params as strings and returns them in a parsed format (like a number or boolean)\n        parseParams?: (\n          rawParams: IsAny<TPath, any, Record<ParsePathParams<TPath>, string>>,\n        ) => TParams extends Record<ParsePathParams<TPath>, any>\n          ? TParams\n          : 'parseParams must return an ojbect'\n        stringifyParams?: (\n          params: NoInfer<TParams>,\n        ) => Record<ParsePathParams<TPath>, string>\n      }\n    | {\n        stringifyParams?: never\n        parseParams?: never\n      }\n  ) &\n  (PickUnsafe<TParentParams, ParsePathParams<TPath>> extends never // Detect if an existing path param is being redefined\n    ? { test?: PickUnsafe<TParentParams, ParsePathParams<TPath>> }\n    : 'Cannot redefined path params in child routes!')\n\n// The parse type here allows a zod schema to be passed directly to the validator\nexport type SearchSchemaValidator<TReturn, TParentSchema> =\n  | SearchSchemaValidatorObj<TReturn, TParentSchema>\n  | SearchSchemaValidatorFn<TReturn, TParentSchema>\n\nexport type SearchSchemaValidatorObj<TReturn, TParentSchema> = {\n  parse?: SearchSchemaValidatorFn<TReturn, TParentSchema>\n}\n\nexport type SearchSchemaValidatorFn<TReturn, TParentSchema> = (\n  searchObj: Record<string, unknown>,\n) => {} extends TParentSchema\n  ? TReturn\n  : keyof TReturn extends keyof TParentSchema\n  ? {\n      error: 'Top level search params cannot be redefined by child routes!'\n      keys: keyof TReturn & keyof TParentSchema\n    }\n  : TReturn\n\nexport type DefinedPathParamWarning =\n  'Path params cannot be redefined by child routes!'\n\nexport type ParentParams<TParentParams> = AnyPathParams extends TParentParams\n  ? {}\n  : {\n      [Key in keyof TParentParams]?: DefinedPathParamWarning\n    }\n\nexport type OnLoadFn<\n  TSearchSchema extends AnySearchSchema = {},\n  TFullSearchSchema extends AnySearchSchema = {},\n  TAllParams = {},\n  TContext extends AnyContext = AnyContext,\n  TAllContext extends AnyContext = AnyContext,\n> = (\n  loaderContext: LoaderContext<\n    TSearchSchema,\n    TFullSearchSchema,\n    TAllParams,\n    TContext,\n    TAllContext\n  >,\n) => Promise<any> | void\n\nexport interface LoaderContext<\n  TSearchSchema extends AnySearchSchema = {},\n  TFullSearchSchema extends AnySearchSchema = {},\n  TAllParams = {},\n  TContext extends AnyContext = AnyContext,\n  TAllContext extends AnyContext = AnyContext,\n> {\n  params: TAllParams\n  routeSearch: TSearchSchema\n  search: TFullSearchSchema\n  signal?: AbortSignal\n  preload: boolean\n  routeContext: TContext\n  context: TAllContext\n}\n\nexport type UnloaderFn<TPath extends string> = (\n  routeMatch: RouteMatch<any, Route>,\n) => void\n\nexport type SearchFilter<T, U = T> = (prev: T) => U\n\ntype ResolveId<\n  TParentRoute,\n  TCustomId extends string,\n  TPath extends string,\n> = TParentRoute extends { id: infer TParentId extends string }\n  ? RoutePrefix<TParentId, string extends TCustomId ? TPath : TCustomId>\n  : RootRouteId\n\nexport type InferFullSearchSchema<TRoute> = TRoute extends {\n  isRoot: true\n  __types: {\n    searchSchema: infer TSearchSchema\n  }\n}\n  ? TSearchSchema\n  : TRoute extends {\n      __types: {\n        fullSearchSchema: infer TFullSearchSchema\n      }\n    }\n  ? TFullSearchSchema\n  : {}\n\nexport type ResolveFullSearchSchema<TParentRoute, TSearchSchema> =\n  InferFullSearchSchema<TParentRoute> & TSearchSchema\n\nexport interface AnyRoute\n  extends Route<\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any\n  > {}\n\ntype MergeFromParent<T, U> = IsAny<T, U, T & U>\n\nexport class Route<\n  TParentRoute extends AnyRoute = AnyRoute,\n  TPath extends string = string,\n  TFullPath extends ResolveFullPath<TParentRoute, TPath> = ResolveFullPath<\n    TParentRoute,\n    TPath\n  >,\n  TCustomId extends string = string,\n  TId extends ResolveId<TParentRoute, TCustomId, TPath> = ResolveId<\n    TParentRoute,\n    TCustomId,\n    TPath\n  >,\n  TSearchSchema extends AnySearchSchema = {},\n  TFullSearchSchema extends AnySearchSchema = ResolveFullSearchSchema<\n    TParentRoute,\n    TSearchSchema\n  >,\n  TParams extends Record<ParsePathParams<TPath>, any> = Record<\n    ParsePathParams<TPath>,\n    string\n  >,\n  TAllParams extends MergeFromParent<\n    TParentRoute['__types']['allParams'],\n    TParams\n  > = MergeFromParent<TParentRoute['__types']['allParams'], TParams>,\n  TParentContext extends TParentRoute['__types']['routeContext'] = TParentRoute['__types']['routeContext'],\n  TAllParentContext extends TParentRoute['__types']['context'] = TParentRoute['__types']['context'],\n  TRouteContext extends RouteContext = RouteContext,\n  TContext extends MergeFromParent<\n    TParentRoute['__types']['context'],\n    TRouteContext\n  > = MergeFromParent<TParentRoute['__types']['context'], TRouteContext>,\n  TRouterContext extends AnyContext = AnyContext,\n  TChildren extends unknown = unknown,\n  TRoutesInfo extends DefaultRoutesInfo = DefaultRoutesInfo,\n> {\n  __types!: {\n    parentRoute: TParentRoute\n    path: TPath\n    fullPath: TFullPath\n    customId: TCustomId\n    id: TId\n    searchSchema: TSearchSchema\n    fullSearchSchema: TFullSearchSchema\n    params: TParams\n    allParams: TAllParams\n    parentContext: TParentContext\n    allParentContext: TAllParentContext\n    routeContext: TRouteContext\n    context: TContext\n    children: TChildren\n    routesInfo: TRoutesInfo\n    routerContext: TRouterContext\n  }\n  isRoot: TParentRoute extends Route<any> ? true : false\n  options: RouteOptions<\n    TParentRoute,\n    TCustomId,\n    TPath,\n    InferFullSearchSchema<TParentRoute>,\n    TSearchSchema,\n    InferFullSearchSchema<TParentRoute> & TSearchSchema,\n    TParentRoute['__types']['allParams'],\n    TParams,\n    TAllParams,\n    TParentContext,\n    TAllParentContext,\n    TRouteContext,\n    TContext\n  >\n\n  // Set up in this.init()\n  parentRoute!: TParentRoute\n  id!: TId\n  // customId!: TCustomId\n  path!: TPath\n  fullPath!: TFullPath\n\n  // Optional\n  children?: TChildren\n  originalIndex?: number\n  router?: Router<TRoutesInfo['routeTree'], TRoutesInfo>\n\n  constructor(\n    options: RouteOptions<\n      TParentRoute,\n      TCustomId,\n      TPath,\n      InferFullSearchSchema<TParentRoute>,\n      TSearchSchema,\n      TFullSearchSchema,\n      TParentRoute['__types']['allParams'],\n      TParams,\n      TAllParams,\n      TParentContext,\n      TAllParentContext,\n      TRouteContext,\n      TContext\n    >,\n  ) {\n    this.options = (options as any) || {}\n    this.isRoot = !options?.getParentRoute as any\n  }\n\n  init = (opts: { originalIndex: number; router: AnyRouter }) => {\n    this.originalIndex = opts.originalIndex\n    this.router = opts.router\n\n    const allOptions = this.options as RouteOptions<\n      TParentRoute,\n      TCustomId,\n      TPath,\n      InferFullSearchSchema<TParentRoute>,\n      TSearchSchema,\n      TFullSearchSchema,\n      TParentRoute['__types']['allParams'],\n      TParams,\n      TAllParams,\n      TParentContext,\n      TAllParentContext,\n      TRouteContext,\n      TContext\n    > &\n      RouteOptionsBaseIntersection<TCustomId, TPath>\n\n    const isRoot = !allOptions?.path && !allOptions?.id\n\n    this.parentRoute = this.options?.getParentRoute?.()\n\n    if (isRoot) {\n      this.path = rootRouteId as TPath\n    } else {\n      invariant(\n        this.parentRoute,\n        `Child Route instances must pass a 'getParentRoute: () => ParentRoute' option that returns a Route instance.`,\n      )\n    }\n\n    let path: undefined | string = isRoot ? rootRouteId : allOptions.path\n\n    // If the path is anything other than an index path, trim it up\n    if (path && path !== '/') {\n      path = trimPath(path)\n    }\n\n    const customId = allOptions?.id || path\n\n    // Strip the parentId prefix from the first level of children\n    let id = isRoot\n      ? rootRouteId\n      : joinPaths([\n          (this.parentRoute.id as any) === rootRouteId\n            ? ''\n            : this.parentRoute.id,\n          customId,\n        ])\n\n    if (path === rootRouteId) {\n      path = '/'\n    }\n\n    if (id !== rootRouteId) {\n      id = joinPaths(['/', id])\n    }\n\n    const fullPath =\n      id === rootRouteId\n        ? '/'\n        : trimPathRight(joinPaths([this.parentRoute.fullPath, path]))\n\n    this.path = path as TPath\n    this.id = id as TId\n    // this.customId = customId as TCustomId\n    this.fullPath = fullPath as TFullPath\n  }\n\n  addChildren = <TNewChildren extends AnyRoute[]>(\n    children: TNewChildren,\n  ): Route<\n    TParentRoute,\n    TPath,\n    TFullPath,\n    TCustomId,\n    TId,\n    TSearchSchema,\n    TFullSearchSchema,\n    TParams,\n    TAllParams,\n    TParentContext,\n    TAllParentContext,\n    TRouteContext,\n    TContext,\n    TRouterContext,\n    TNewChildren,\n    TRoutesInfo\n  > => {\n    this.children = children as any\n    return this as any\n  }\n\n  // generate = (\n  //   options: Omit<\n  //     RouteOptions<\n  //       TParentRoute,\n  //       TCustomId,\n  //       TPath,\n  //       InferFullSearchSchema<TParentRoute>,\n  //       TSearchSchema,\n  //       TFullSearchSchema,\n  //       TParentRoute['__types']['allParams'],\n  //       TParams,\n  //       TAllParams,\n  //       TParentContext,\n  //       TAllParentContext,\n  //       TRouteContext,\n  //       TContext\n  //     >,\n  //     'path'\n  //   >,\n  // ) => {\n  //   invariant(\n  //     false,\n  //     `route.generate() is used by TanStack Router's file-based routing code generation and should not actually be called during runtime. `,\n  //   )\n  // }\n}\n\nexport type AnyRootRoute = RootRoute<any, any, any>\n\nexport class RootRoute<\n  TSearchSchema extends AnySearchSchema = {},\n  TContext extends RouteContext = RouteContext,\n  TRouterContext extends RouterContext = RouterContext,\n> extends Route<\n  any,\n  '/',\n  '/',\n  string,\n  RootRouteId,\n  TSearchSchema,\n  TSearchSchema,\n  {},\n  {},\n  TRouterContext,\n  TRouterContext,\n  TContext,\n  MergeFromParent<TRouterContext, TContext>,\n  TRouterContext\n> {\n  constructor(\n    options?: Omit<\n      RouteOptions<\n        AnyRoute,\n        RootRouteId,\n        '',\n        {},\n        TSearchSchema,\n        NoInfer<TSearchSchema>,\n        {},\n        TRouterContext,\n        TRouterContext,\n        TContext,\n        NoInfer<TContext>\n      >,\n      | 'path'\n      | 'id'\n      | 'getParentRoute'\n      | 'caseSensitive'\n      | 'parseParams'\n      | 'stringifyParams'\n    >,\n  ) {\n    super(options as any)\n  }\n\n  static withRouterContext = <TRouterContext extends RouterContext>() => {\n    return <\n      TSearchSchema extends AnySearchSchema = {},\n      TContext extends RouterContext = RouterContext,\n    >(\n      options?: Omit<\n        RouteOptions<\n          AnyRoute,\n          RootRouteId,\n          '',\n          {},\n          TSearchSchema,\n          NoInfer<TSearchSchema>,\n          {},\n          TRouterContext,\n          TRouterContext,\n          TContext,\n          TRouterContext & TContext\n        >,\n        'path' | 'id' | 'getParentRoute' | 'caseSensitive'\n      >,\n    ) => new RootRoute<TSearchSchema, TContext, TRouterContext>(options as any)\n  }\n}\n\ntype ResolveFullPath<\n  TParentRoute extends AnyRoute,\n  TPath extends string,\n  TPrefixed extends RoutePrefix<TParentRoute['fullPath'], TPath> = RoutePrefix<\n    TParentRoute['fullPath'],\n    TPath\n  >,\n> = TPrefixed extends RootRouteId ? '/' : TrimPathRight<`${TPrefixed}`>\n\ntype RoutePrefix<\n  TPrefix extends string,\n  TId extends string,\n> = string extends TId\n  ? RootRouteId\n  : TId extends string\n  ? TPrefix extends RootRouteId\n    ? TId extends '/'\n      ? '/'\n      : `/${TrimPath<TId>}`\n    : `${TPrefix}/${TId}` extends '/'\n    ? '/'\n    : `/${TrimPathLeft<`${TrimPathRight<TPrefix>}/${TrimPath<TId>}`>}`\n  : never\n\ntype TrimPath<T extends string> = '' extends T\n  ? ''\n  : TrimPathRight<TrimPathLeft<T>>\n\ntype TrimPathLeft<T extends string> = T extends `${RootRouteId}/${infer U}`\n  ? TrimPathLeft<U>\n  : T extends `/${infer U}`\n  ? TrimPathLeft<U>\n  : T\ntype TrimPathRight<T extends string> = T extends '/'\n  ? '/'\n  : T extends `${infer U}/`\n  ? TrimPathRight<U>\n  : T\n\n// const rootRoute = new RootRoute({\n//   validateSearch: () => null as unknown as { root?: boolean },\n// })\n\n// const aRoute = new Route({\n//   getParentRoute: () => rootRoute,\n//   path: 'a',\n//   validateSearch: () => null as unknown as { a?: string },\n// })\n\n// const bRoute = new Route({\n//   getParentRoute: () => aRoute,\n//   path: 'b',\n// })\n\n// const rootIsRoot = rootRoute.isRoot\n// //    ^?\n// const aIsRoot = aRoute.isRoot\n// //    ^?\n\n// const rId = rootRoute.id\n// //    ^?\n// const aId = aRoute.id\n// //    ^?\n// const bId = bRoute.id\n// //    ^?\n\n// const rPath = rootRoute.fullPath\n// //    ^?\n// const aPath = aRoute.fullPath\n// //    ^?\n// const bPath = bRoute.fullPath\n// //    ^?\n\n// const rSearch = rootRoute.__types.fullSearchSchema\n// //    ^?\n// const aSearch = aRoute.__types.fullSearchSchema\n// //    ^?\n// const bSearch = bRoute.__types.fullSearchSchema\n// //    ^?\n\n// const config = rootRoute.addChildren([aRoute.addChildren([bRoute])])\n// //    ^?\n","/**\n * store\n *\n * Copyright (c) TanStack\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nclass Store {\n  listeners = new Set();\n  batching = false;\n  queue = [];\n  constructor(initialState, options) {\n    this.state = initialState;\n    this.options = options;\n  }\n  subscribe = listener => {\n    this.listeners.add(listener);\n    const unsub = this.options?.onSubscribe?.(listener, this);\n    return () => {\n      this.listeners.delete(listener);\n      unsub?.();\n    };\n  };\n  setState = updater => {\n    const previous = this.state;\n    this.state = this.options?.updateFn ? this.options.updateFn(previous)(updater) : updater(previous);\n    if (this.state === previous) return;\n    this.options?.onUpdate?.(this.state, previous);\n    this.queue.push(() => {\n      this.listeners.forEach(listener => listener(this.state, previous));\n    });\n    this.#flush();\n  };\n  #flush = () => {\n    if (this.batching) return;\n    this.queue.forEach(cb => cb());\n    this.queue = [];\n  };\n  batch = cb => {\n    this.batching = true;\n    cb();\n    this.batching = false;\n    this.#flush();\n  };\n}\nfunction shallow(objA, objB) {\n  if (Object.is(objA, objB)) {\n    return true;\n  }\n  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {\n    return false;\n  }\n\n  // if (objA instanceof Map && objB instanceof Map) {\n  //   if (objA.size !== objB.size) return false\n\n  //   for (const [key, value] of objA) {\n  //     if (!Object.is(value, objB.get(key))) {\n  //       return false\n  //     }\n  //   }\n  //   return true\n  // }\n\n  // if (objA instanceof Set && objB instanceof Set) {\n  //   if (objA.size !== objB.size) return false\n\n  //   for (const value of objA) {\n  //     if (!objB.has(value)) {\n  //       return false\n  //     }\n  //   }\n  //   return true\n  // }\n\n  const keysA = Object.keys(objA);\n  if (keysA.length !== Object.keys(objB).length) {\n    return false;\n  }\n  for (let i = 0; i < keysA.length; i++) {\n    if (!Object.prototype.hasOwnProperty.call(objB, keysA[i]) || !Object.is(objA[keysA[i]], objB[keysA[i]])) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport { Store, shallow };\n//# sourceMappingURL=index.js.map\n","import { decode, encode } from './qss'\nimport { AnySearchSchema } from './route'\n\nexport const defaultParseSearch = parseSearchWith(JSON.parse)\nexport const defaultStringifySearch = stringifySearchWith(JSON.stringify)\n\nexport function parseSearchWith(parser: (str: string) => any) {\n  return (searchStr: string): AnySearchSchema => {\n    if (searchStr.substring(0, 1) === '?') {\n      searchStr = searchStr.substring(1)\n    }\n\n    let query: Record<string, unknown> = decode(searchStr)\n\n    // Try to parse any query params that might be json\n    for (let key in query) {\n      const value = query[key]\n      if (typeof value === 'string') {\n        try {\n          query[key] = parser(value)\n        } catch (err) {\n          //\n        }\n      }\n    }\n\n    return query\n  }\n}\n\nexport function stringifySearchWith(stringify: (search: any) => string) {\n  return (search: Record<string, any>) => {\n    search = { ...search }\n\n    if (search) {\n      Object.keys(search).forEach((key) => {\n        const val = search[key]\n        if (typeof val === 'undefined' || val === undefined) {\n          delete search[key]\n        } else if (val && typeof val === 'object' && val !== null) {\n          try {\n            search[key] = stringify(val)\n          } catch (err) {\n            // silent\n          }\n        }\n      })\n    }\n\n    const searchStr = encode(search as Record<string, string>).toString()\n\n    return searchStr ? `?${searchStr}` : ''\n  }\n}\n","import { Store } from '@tanstack/store'\nimport invariant from 'tiny-invariant'\n\n//\n\nimport { GetFrameworkGeneric } from './frameworks'\n\nimport {\n  LinkInfo,\n  LinkOptions,\n  NavigateOptions,\n  ToOptions,\n  ValidFromPath,\n  ResolveRelativePath,\n} from './link'\nimport {\n  cleanPath,\n  interpolatePath,\n  joinPaths,\n  matchPathname,\n  parsePathname,\n  resolvePath,\n  trimPath,\n  trimPathLeft,\n} from './path'\nimport {\n  Route,\n  AnySearchSchema,\n  AnyRoute,\n  RootRoute,\n  AnyContext,\n} from './route'\nimport { RoutesInfo, AnyRoutesInfo, RoutesById } from './routeInfo'\nimport { AnyRouteMatch, RouteMatch, RouteMatchStore } from './routeMatch'\nimport { defaultParseSearch, defaultStringifySearch } from './searchParams'\nimport {\n  functionalUpdate,\n  last,\n  NoInfer,\n  pick,\n  PickAsRequired,\n  Timeout,\n  Updater,\n  replaceEqualDeep,\n  partialDeepEqual,\n} from './utils'\nimport {\n  createBrowserHistory,\n  createMemoryHistory,\n  RouterHistory,\n} from './history'\n\nexport interface Register {\n  // router: Router\n}\n\nexport type AnyRouter = Router<any, any>\n\nexport type RegisteredRouter = Register extends {\n  router: Router<infer TRoute, infer TRoutesInfo>\n}\n  ? Router<TRoute, TRoutesInfo>\n  : Router\n\nexport type RegisteredRoutesInfo = Register extends {\n  router: Router<infer TRoute, infer TRoutesInfo>\n}\n  ? TRoutesInfo\n  : AnyRoutesInfo\n\nexport interface LocationState {}\n\nexport interface ParsedLocation<\n  TSearchObj extends AnySearchSchema = {},\n  TState extends LocationState = LocationState,\n> {\n  href: string\n  pathname: string\n  search: TSearchObj\n  searchStr: string\n  state: TState\n  hash: string\n  key?: string\n}\n\nexport interface FromLocation {\n  pathname: string\n  search?: unknown\n  key?: string\n  hash?: string\n}\n\nexport type SearchSerializer = (searchObj: Record<string, any>) => string\nexport type SearchParser = (searchStr: string) => Record<string, any>\nexport type FilterRoutesFn = <TRoute extends AnyRoute>(\n  routes: TRoute[],\n) => TRoute[]\n\ntype RouterContextOptions<TRouteTree extends AnyRoute> =\n  AnyContext extends TRouteTree['__types']['routerContext']\n    ? {\n        context?: TRouteTree['__types']['routerContext']\n      }\n    : {\n        context: TRouteTree['__types']['routerContext']\n      }\n\nexport interface RouterOptions<TRouteTree extends AnyRoute> {\n  history?: RouterHistory\n  stringifySearch?: SearchSerializer\n  parseSearch?: SearchParser\n  filterRoutes?: FilterRoutesFn\n  defaultPreload?: false | 'intent'\n  defaultPreloadDelay?: number\n  defaultComponent?: GetFrameworkGeneric<'Component'>\n  defaultErrorComponent?: GetFrameworkGeneric<'ErrorComponent'>\n  defaultPendingComponent?: GetFrameworkGeneric<'Component'>\n  defaultLoaderMaxAge?: number\n  defaultLoaderGcMaxAge?: number\n  caseSensitive?: boolean\n  routeTree?: TRouteTree\n  basepath?: string\n  Router?: (router: AnyRouter) => void\n  createRoute?: (opts: { route: AnyRoute; router: AnyRouter }) => void\n  loadComponent?: (\n    component: GetFrameworkGeneric<'Component'>,\n  ) => Promise<GetFrameworkGeneric<'Component'>>\n  onRouteChange?: () => void\n  fetchServerDataFn?: FetchServerDataFn\n  context?: TRouteTree['__types']['routerContext']\n}\n\ntype FetchServerDataFn = (ctx: {\n  router: AnyRouter\n  routeMatch: RouteMatch\n}) => Promise<any>\n\nexport interface RouterStore<\n  TRoutesInfo extends AnyRoutesInfo = AnyRoutesInfo,\n  TState extends LocationState = LocationState,\n> {\n  status: 'idle' | 'pending'\n  latestLocation: ParsedLocation<TRoutesInfo['fullSearchSchema'], TState>\n  currentMatches: RouteMatch<TRoutesInfo, TRoutesInfo['routeIntersection']>[]\n  currentLocation: ParsedLocation<TRoutesInfo['fullSearchSchema'], TState>\n  pendingMatches?: RouteMatch<TRoutesInfo, TRoutesInfo['routeIntersection']>[]\n  pendingLocation?: ParsedLocation<TRoutesInfo['fullSearchSchema'], TState>\n  lastUpdated: number\n}\n\nexport type ListenerFn = () => void\n\nexport interface BuildNextOptions {\n  to?: string | number | null\n  params?: true | Updater<unknown>\n  search?: true | Updater<unknown>\n  hash?: true | Updater<string>\n  state?: LocationState\n  key?: string\n  from?: string\n  fromCurrent?: boolean\n  __matches?: RouteMatch[]\n}\n\nexport type MatchCacheEntry = {\n  gc: number\n  match: RouteMatch\n}\n\nexport interface MatchLocation {\n  to?: string | number | null\n  fuzzy?: boolean\n  caseSensitive?: boolean\n  from?: string\n  fromCurrent?: boolean\n}\n\nexport interface MatchRouteOptions {\n  pending?: boolean\n  caseSensitive?: boolean\n  includeSearch?: boolean\n  fuzzy?: boolean\n}\n\ntype LinkCurrentTargetElement = {\n  preloadTimeout?: null | ReturnType<typeof setTimeout>\n}\n\nexport interface DehydratedRouterState\n  extends Pick<\n    RouterStore,\n    'status' | 'latestLocation' | 'currentLocation' | 'lastUpdated'\n  > {\n  currentMatches: DehydratedRouteMatch[]\n}\n\nexport interface DehydratedRouter {\n  state: DehydratedRouterState\n}\n\nexport type MatchCache = Record<string, MatchCacheEntry>\n\ninterface DehydratedRouteMatch {\n  id: string\n  state: Pick<RouteMatchStore<any, any>, 'status'>\n}\n\nexport interface RouterContext {}\n\nexport const defaultFetchServerDataFn: FetchServerDataFn = async ({\n  router,\n  routeMatch,\n}) => {\n  const next = router.buildNext({\n    to: '.',\n    search: (d: any) => ({\n      ...(d ?? {}),\n      __data: {\n        matchId: routeMatch.id,\n      },\n    }),\n  })\n\n  const res = await fetch(next.href, {\n    method: 'GET',\n    signal: routeMatch.abortController.signal,\n  })\n\n  if (res.ok) {\n    return res.json()\n  }\n\n  throw new Error('Failed to fetch match data')\n}\n\nexport type RouterConstructorOptions<TRouteTree extends AnyRoute> = Omit<\n  RouterOptions<TRouteTree>,\n  'context'\n> &\n  RouterContextOptions<TRouteTree>\n\nexport class Router<\n  TRouteTree extends AnyRoute = RootRoute,\n  TRoutesInfo extends AnyRoutesInfo = RoutesInfo<TRouteTree>,\n> {\n  types!: {\n    // Super secret internal stuff\n    RootRoute: TRouteTree\n    RoutesInfo: TRoutesInfo\n  }\n\n  options: PickAsRequired<\n    RouterOptions<TRouteTree>,\n    'stringifySearch' | 'parseSearch' | 'context'\n  >\n  history!: RouterHistory\n  #unsubHistory?: () => void\n  basepath: string\n  // __location: Location<TRoutesInfo['fullSearchSchema']>\n  routeTree!: RootRoute\n  routesById!: RoutesById<TRoutesInfo>\n  navigateTimeout: undefined | Timeout\n  nextAction: undefined | 'push' | 'replace'\n  navigationPromise: undefined | Promise<void>\n\n  __store: Store<RouterStore<TRoutesInfo>>\n  state: RouterStore<TRoutesInfo>\n  startedLoadingAt = Date.now()\n  resolveNavigation: () => void = () => {}\n\n  constructor(options?: RouterConstructorOptions<TRouteTree>) {\n    this.options = {\n      defaultPreloadDelay: 50,\n      context: undefined!,\n      ...options,\n      stringifySearch: options?.stringifySearch ?? defaultStringifySearch,\n      parseSearch: options?.parseSearch ?? defaultParseSearch,\n      fetchServerDataFn: options?.fetchServerDataFn ?? defaultFetchServerDataFn,\n    }\n\n    this.__store = new Store<RouterStore<TRoutesInfo>>(\n      getInitialRouterState(),\n      {\n        onUpdate: (state) => {\n          this.state = state\n        },\n      },\n    )\n    this.state = this.__store.state\n    this.basepath = ''\n\n    this.update(options)\n\n    // Allow frameworks to hook into the router creation\n    this.options.Router?.(this)\n\n    const next = this.buildNext({\n      hash: true,\n      fromCurrent: true,\n      search: true,\n      state: true,\n    })\n\n    if (this.state.latestLocation.href !== next.href) {\n      this.#commitLocation({ ...next, replace: true })\n    }\n  }\n\n  reset = () => {\n    this.__store.setState((s) => Object.assign(s, getInitialRouterState()))\n  }\n\n  mount = () => {\n    // Mount only does anything on the client\n    if (!isServer) {\n      // If the router matches are empty, start loading the matches\n      if (!this.state.currentMatches.length) {\n        this.safeLoad()\n      }\n    }\n\n    return () => {}\n  }\n\n  update = (opts?: RouterOptions<TRouteTree>): this => {\n    Object.assign(this.options, opts)\n\n    if (\n      !this.history ||\n      (this.options.history && this.options.history !== this.history)\n    ) {\n      if (this.#unsubHistory) {\n        this.#unsubHistory()\n      }\n\n      this.history =\n        this.options.history ??\n        (isServer ? createMemoryHistory() : createBrowserHistory()!)\n\n      const parsedLocation = this.#parseLocation()\n\n      this.__store.setState((s) => ({\n        ...s,\n        latestLocation: parsedLocation,\n        currentLocation: parsedLocation,\n      }))\n\n      this.#unsubHistory = this.history.listen(() => {\n        this.safeLoad({\n          next: this.#parseLocation(this.state.latestLocation),\n        })\n      })\n    }\n\n    const { basepath, routeTree } = this.options\n\n    this.basepath = `/${trimPath(basepath ?? '') ?? ''}`\n\n    if (routeTree) {\n      this.routesById = {} as any\n      this.routeTree = this.#buildRouteTree(routeTree)\n    }\n\n    return this\n  }\n\n  buildNext = (opts: BuildNextOptions) => {\n    const next = this.#buildLocation(opts)\n\n    const __matches = this.matchRoutes(next.pathname)\n\n    return this.#buildLocation({\n      ...opts,\n      __matches,\n    })\n  }\n\n  cancelMatches = () => {\n    ;[\n      ...this.state.currentMatches,\n      ...(this.state.pendingMatches || []),\n    ].forEach((match) => {\n      match.cancel()\n    })\n  }\n\n  safeLoad = (opts?: { next?: ParsedLocation }) => {\n    this.load(opts).catch((err) => {\n      console.warn(err)\n      invariant(false, 'Encountered an error during router.load()! .')\n    })\n  }\n\n  load = async (opts?: { next?: ParsedLocation }): Promise<void> => {\n    let now = Date.now()\n    const startedAt = now\n    this.startedLoadingAt = startedAt\n\n    // Cancel any pending matches\n    this.cancelMatches()\n\n    let matches!: RouteMatch<any, any>[]\n\n    this.__store.batch(() => {\n      if (opts?.next) {\n        // Ingest the new location\n        this.__store.setState((s) => ({\n          ...s,\n          latestLocation: opts.next!,\n        }))\n      }\n\n      // Match the routes\n      matches = this.matchRoutes(this.state.latestLocation.pathname, {\n        strictParseParams: true,\n      })\n\n      this.__store.setState((s) => ({\n        ...s,\n        status: 'pending',\n        pendingMatches: matches,\n        pendingLocation: this.state.latestLocation,\n      }))\n    })\n\n    // Load the matches\n    await this.loadMatches(\n      matches,\n      this.state.pendingLocation!,\n      // opts\n    )\n\n    if (this.startedLoadingAt !== startedAt) {\n      // Ignore side-effects of outdated side-effects\n      return this.navigationPromise\n    }\n\n    const previousMatches = this.state.currentMatches\n\n    const exiting: AnyRouteMatch[] = [],\n      staying: AnyRouteMatch[] = []\n\n    previousMatches.forEach((d) => {\n      if (matches.find((dd) => dd.id === d.id)) {\n        staying.push(d)\n      } else {\n        exiting.push(d)\n      }\n    })\n\n    const entering = matches.filter((d) => {\n      return !previousMatches.find((dd) => dd.id === d.id)\n    })\n\n    now = Date.now()\n\n    exiting.forEach((d) => {\n      d.__onExit?.({\n        params: d.params,\n        search: d.state.routeSearch,\n      })\n\n      // Clear non-loading error states when match leaves\n      if (d.state.status === 'error') {\n        this.__store.setState((s) => ({\n          ...s,\n          status: 'idle',\n          error: undefined,\n        }))\n      }\n    })\n\n    staying.forEach((d) => {\n      d.route.options.onTransition?.({\n        params: d.params,\n        search: d.state.routeSearch,\n      })\n    })\n\n    entering.forEach((d) => {\n      d.__onExit = d.route.options.onLoaded?.({\n        params: d.params,\n        search: d.state.search,\n      })\n    })\n\n    const prevLocation = this.state.currentLocation\n\n    this.__store.setState((s) => ({\n      ...s,\n      status: 'idle',\n      currentLocation: this.state.latestLocation,\n      currentMatches: matches,\n      pendingLocation: undefined,\n      pendingMatches: undefined,\n    }))\n\n    matches.forEach((match) => {\n      match.__commit()\n    })\n\n    if (prevLocation!.href !== this.state.currentLocation.href) {\n      this.options.onRouteChange?.()\n    }\n\n    this.resolveNavigation()\n  }\n\n  getRoute = <TId extends keyof TRoutesInfo['routesById']>(\n    id: TId,\n  ): TRoutesInfo['routesById'][TId] => {\n    const route = this.routesById[id]\n\n    invariant(route, `Route with id \"${id as string}\" not found`)\n\n    return route\n  }\n\n  loadRoute = async (\n    navigateOpts: BuildNextOptions = this.state.latestLocation,\n  ): Promise<RouteMatch[]> => {\n    const next = this.buildNext(navigateOpts)\n    const matches = this.matchRoutes(next.pathname, {\n      strictParseParams: true,\n    })\n    await this.loadMatches(matches, next)\n    return matches\n  }\n\n  preloadRoute = async (\n    navigateOpts: BuildNextOptions = this.state.latestLocation,\n  ) => {\n    const next = this.buildNext(navigateOpts)\n    const matches = this.matchRoutes(next.pathname, {\n      strictParseParams: true,\n    })\n\n    await this.loadMatches(matches, next, {\n      preload: true,\n    })\n    return matches\n  }\n\n  matchRoutes = (pathname: string, opts?: { strictParseParams?: boolean }) => {\n    const matches: AnyRouteMatch[] = []\n\n    if (!this.routeTree) {\n      return matches\n    }\n\n    const existingMatches = [\n      ...this.state.currentMatches,\n      ...(this.state.pendingMatches ?? []),\n    ]\n\n    const findInRouteTree = async (\n      routes: Route<any, any>[],\n    ): Promise<void> => {\n      const parentMatch = last(matches)\n      let params = parentMatch?.params ?? {}\n\n      const filteredRoutes = this.options.filterRoutes?.(routes) ?? routes\n\n      let matchingRoutes: Route[] = []\n\n      const findMatchInRoutes = (parentRoutes: Route[], routes: Route[]) => {\n        routes.some((route) => {\n          const children = route.children as undefined | Route[]\n          if (!route.path && children?.length) {\n            return findMatchInRoutes(\n              [...matchingRoutes, route],\n              children as any,\n            )\n          }\n\n          const fuzzy = !!(route.path !== '/' || children?.length)\n\n          const matchParams = matchPathname(this.basepath, pathname, {\n            to: route.fullPath,\n            fuzzy,\n            caseSensitive:\n              route.options.caseSensitive ?? this.options.caseSensitive,\n          })\n\n          if (matchParams) {\n            let parsedParams\n\n            try {\n              parsedParams =\n                route.options.parseParams?.(matchParams!) ?? matchParams\n            } catch (err) {\n              if (opts?.strictParseParams) {\n                throw err\n              }\n            }\n\n            params = {\n              ...params,\n              ...parsedParams,\n            }\n          }\n\n          if (!!matchParams) {\n            matchingRoutes = [...parentRoutes, route]\n          }\n\n          return !!matchingRoutes.length\n        })\n\n        return !!matchingRoutes.length\n      }\n\n      findMatchInRoutes([], filteredRoutes)\n\n      if (!matchingRoutes.length) {\n        return\n      }\n\n      matchingRoutes.forEach((foundRoute) => {\n        const interpolatedPath = interpolatePath(foundRoute.path, params)\n        const matchId = interpolatePath(foundRoute.id, params, true)\n\n        const match =\n          existingMatches.find((d) => d.id === matchId) ||\n          new RouteMatch(this, foundRoute, {\n            id: matchId,\n            params,\n            pathname: joinPaths([this.basepath, interpolatedPath]),\n          })\n\n        matches.push(match)\n      })\n\n      const foundRoute = last(matchingRoutes)!\n\n      const foundChildren = foundRoute.children as any\n\n      if (foundChildren?.length) {\n        findInRouteTree(foundChildren)\n      }\n    }\n\n    findInRouteTree([this.routeTree as any])\n\n    return matches\n  }\n\n  loadMatches = async (\n    resolvedMatches: RouteMatch[],\n    location: ParsedLocation,\n    opts?: {\n      preload?: boolean\n      // filter?: (match: RouteMatch<any, any>) => any\n    },\n  ) => {\n    let firstBadMatchIndex: number | undefined\n\n    // Check each match middleware to see if the route can be accessed\n    try {\n      await Promise.all(\n        resolvedMatches.map(async (match, index) => {\n          try {\n            await match.route.options.beforeLoad?.({\n              router: this as any,\n              match,\n            })\n          } catch (err) {\n            if (isRedirect(err)) {\n              throw err\n            }\n\n            firstBadMatchIndex = firstBadMatchIndex ?? index\n\n            const errorHandler = match.route.options.onBeforeLoadError ?? match.route.options.onError\n            try {\n              errorHandler?.(err)\n            } catch (errorHandlerErr) {\n              if (isRedirect(errorHandlerErr)) {\n                throw errorHandlerErr\n              }\n\n              match.__store.setState((s) => ({\n                ...s,\n                error: errorHandlerErr,\n                status: 'error',\n                updatedAt: Date.now(),\n              }))\n              return\n            }\n\n            match.__store.setState((s) => ({\n              ...s,\n              error: err,\n              status: 'error',\n              updatedAt: Date.now(),\n            }))\n          }\n        }),\n      )\n    } catch (err) {\n      if (isRedirect(err)) {\n        if (!opts?.preload) {\n          this.navigate(err as any)\n        }\n        return\n      }\n\n      throw err // we should never end up here\n    }\n\n    const validResolvedMatches = resolvedMatches.slice(0, firstBadMatchIndex)\n    const matchPromises = validResolvedMatches.map(async (match, index) => {\n      const parentMatch = validResolvedMatches[index - 1]\n\n      match.__load({ preload: opts?.preload, location, parentMatch })\n\n      await match.__loadPromise\n\n      if (parentMatch) {\n        await parentMatch.__loadPromise\n      }\n    })\n\n    await Promise.all(matchPromises)\n  }\n\n  reload = () => {\n    this.navigate({\n      fromCurrent: true,\n      replace: true,\n      search: true,\n    } as any)\n  }\n\n  resolvePath = (from: string, path: string) => {\n    return resolvePath(this.basepath!, from, cleanPath(path))\n  }\n\n  navigate = async <\n    TFrom extends ValidFromPath<TRoutesInfo> = '/',\n    TTo extends string = '',\n  >({\n    from,\n    to = '' as any,\n    search,\n    hash,\n    replace,\n    params,\n  }: NavigateOptions<TRoutesInfo, TFrom, TTo>) => {\n    // If this link simply reloads the current route,\n    // make sure it has a new key so it will trigger a data refresh\n\n    // If this `to` is a valid external URL, return\n    // null for LinkUtils\n    const toString = String(to)\n    const fromString = typeof from === 'undefined' ? from : String(from)\n    let isExternal\n\n    try {\n      new URL(`${toString}`)\n      isExternal = true\n    } catch (e) {}\n\n    invariant(\n      !isExternal,\n      'Attempting to navigate to external url with this.navigate!',\n    )\n\n    return this.#commitLocation({\n      from: fromString,\n      to: toString,\n      search,\n      hash,\n      replace,\n      params,\n    })\n  }\n\n  matchRoute = <\n    TFrom extends ValidFromPath<TRoutesInfo> = '/',\n    TTo extends string = '',\n    TResolved extends string = ResolveRelativePath<TFrom, NoInfer<TTo>>,\n  >(\n    location: ToOptions<TRoutesInfo, TFrom, TTo>,\n    opts?: MatchRouteOptions,\n  ): false | TRoutesInfo['routesById'][TResolved]['__types']['allParams'] => {\n    location = {\n      ...location,\n      to: location.to\n        ? this.resolvePath(location.from ?? '', location.to)\n        : undefined,\n    } as any\n\n    const next = this.buildNext(location)\n    const baseLocation = opts?.pending\n      ? this.state.pendingLocation\n      : this.state.currentLocation\n\n    if (!baseLocation) {\n      return false\n    }\n\n    const match = matchPathname(this.basepath, baseLocation.pathname, {\n      ...opts,\n      to: next.pathname,\n    }) as any\n\n    if (!match) {\n      return false\n    }\n\n    if (opts?.includeSearch ?? true) {\n      return partialDeepEqual(baseLocation.search, next.search) ? match : false\n    }\n\n    return match\n  }\n\n  buildLink = <\n    TFrom extends ValidFromPath<TRoutesInfo> = '/',\n    TTo extends string = '',\n  >({\n    from,\n    to = '.' as any,\n    search,\n    params,\n    hash,\n    target,\n    replace,\n    activeOptions,\n    preload,\n    preloadDelay: userPreloadDelay,\n    disabled,\n  }: LinkOptions<TRoutesInfo, TFrom, TTo>): LinkInfo => {\n    // If this link simply reloads the current route,\n    // make sure it has a new key so it will trigger a data refresh\n\n    // If this `to` is a valid external URL, return\n    // null for LinkUtils\n\n    try {\n      new URL(`${to}`)\n      return {\n        type: 'external',\n        href: to,\n      }\n    } catch (e) {}\n\n    const nextOpts = {\n      from,\n      to,\n      search,\n      params,\n      hash,\n      replace,\n    }\n\n    const next = this.buildNext(nextOpts)\n\n    preload = preload ?? this.options.defaultPreload\n    const preloadDelay =\n      userPreloadDelay ?? this.options.defaultPreloadDelay ?? 0\n\n    // Compare path/hash for matches\n    const currentPathSplit = this.state.currentLocation.pathname.split('/')\n    const nextPathSplit = next.pathname.split('/')\n    const pathIsFuzzyEqual = nextPathSplit.every(\n      (d, i) => d === currentPathSplit[i],\n    )\n    // Combine the matches based on user options\n    const pathTest = activeOptions?.exact\n      ? this.state.currentLocation.pathname === next.pathname\n      : pathIsFuzzyEqual\n    const hashTest = activeOptions?.includeHash\n      ? this.state.currentLocation.hash === next.hash\n      : true\n    const searchTest =\n      activeOptions?.includeSearch ?? true\n        ? partialDeepEqual(this.state.currentLocation.search, next.search)\n        : true\n\n    // The final \"active\" test\n    const isActive = pathTest && hashTest && searchTest\n\n    // The click handler\n    const handleClick = (e: MouseEvent) => {\n      if (\n        !disabled &&\n        !isCtrlEvent(e) &&\n        !e.defaultPrevented &&\n        (!target || target === '_self') &&\n        e.button === 0\n      ) {\n        e.preventDefault()\n\n        // All is well? Navigate!\n        this.#commitLocation(nextOpts as any)\n      }\n    }\n\n    // The click handler\n    const handleFocus = (e: MouseEvent) => {\n      if (preload) {\n        this.preloadRoute(nextOpts).catch((err) => {\n          console.warn(err)\n          console.warn('Error preloading route! ')\n        })\n      }\n    }\n\n    const handleTouchStart = (e: TouchEvent) => {\n      this.preloadRoute(nextOpts).catch((err) => {\n        console.warn(err)\n        console.warn('Error preloading route! ')\n      })\n    }\n\n    const handleEnter = (e: MouseEvent) => {\n      const target = (e.target || {}) as LinkCurrentTargetElement\n\n      if (preload) {\n        if (target.preloadTimeout) {\n          return\n        }\n\n        target.preloadTimeout = setTimeout(() => {\n          target.preloadTimeout = null\n          this.preloadRoute(nextOpts).catch((err) => {\n            console.warn(err)\n            console.warn('Error preloading route! ')\n          })\n        }, preloadDelay)\n      }\n    }\n\n    const handleLeave = (e: MouseEvent) => {\n      const target = (e.target || {}) as LinkCurrentTargetElement\n\n      if (target.preloadTimeout) {\n        clearTimeout(target.preloadTimeout)\n        target.preloadTimeout = null\n      }\n    }\n\n    return {\n      type: 'internal',\n      next,\n      handleFocus,\n      handleClick,\n      handleEnter,\n      handleLeave,\n      handleTouchStart,\n      isActive,\n      disabled,\n    }\n  }\n\n  dehydrate = (): DehydratedRouter => {\n    return {\n      state: {\n        ...pick(this.state, [\n          'latestLocation',\n          'currentLocation',\n          'status',\n          'lastUpdated',\n        ]),\n        currentMatches: this.state.currentMatches.map((match) => ({\n          id: match.id,\n          state: {\n            status: match.state.status,\n          },\n        })),\n      },\n    }\n  }\n\n  hydrate = (dehydratedRouter: DehydratedRouter) => {\n    this.__store.setState((s) => {\n      // Match the routes\n      const currentMatches = this.matchRoutes(\n        dehydratedRouter.state.latestLocation.pathname,\n        {\n          strictParseParams: true,\n        },\n      )\n\n      currentMatches.forEach((match, index) => {\n        const dehydratedMatch = dehydratedRouter.state.currentMatches[index]\n        invariant(\n          dehydratedMatch && dehydratedMatch.id === match.id,\n          'Oh no! There was a hydration mismatch when attempting to hydrate the state of the router! ',\n        )\n        match.__store.setState((s) => ({\n          ...s,\n          ...dehydratedMatch.state,\n        }))\n      })\n\n      return {\n        ...s,\n        ...dehydratedRouter.state,\n        currentMatches,\n      }\n    })\n  }\n\n  #buildRouteTree = (routeTree: AnyRoute) => {\n    const recurseRoutes = (routes: Route[], parentRoute: Route | undefined) => {\n      routes.forEach((route, i) => {\n        route.init({ originalIndex: i, router: this })\n\n        const existingRoute = (this.routesById as any)[route.id]\n\n        invariant(\n          !existingRoute,\n          `Duplicate routes found with id: ${String(route.id)}`,\n        )\n        ;(this.routesById as any)[route.id] = route\n\n        const children = route.children as Route[]\n\n        if (children?.length) {\n          recurseRoutes(children, route)\n\n          route.children = children\n            .map((d, i) => {\n              const parsed = parsePathname(\n                trimPathLeft(cleanPath(d.path ?? '/')),\n              )\n\n              while (parsed.length > 1 && parsed[0]?.value === '/') {\n                parsed.shift()\n              }\n\n              let score = 0\n\n              parsed.forEach((d, i) => {\n                let modifier = 1\n                while (i--) {\n                  modifier *= 0.001\n                }\n                if (d.type === 'pathname' && d.value !== '/') {\n                  score += 1 * modifier\n                } else if (d.type === 'param') {\n                  score += 2 * modifier\n                } else if (d.type === 'wildcard') {\n                  score += 3 * modifier\n                }\n              })\n\n              return { child: d, parsed, index: i, score }\n            })\n            .sort((a, b) => {\n              if (a.score !== b.score) {\n                return a.score - b.score\n              }\n\n              return a.index - b.index\n            })\n            .map((d) => d.child)\n        }\n      })\n    }\n\n    recurseRoutes([routeTree] as Route[], undefined)\n\n    const recurceCheckRoutes = (\n      routes: Route[],\n      parentRoute: Route | undefined,\n    ) => {\n      routes.forEach((route) => {\n        if (route.isRoot) {\n          invariant(\n            !parentRoute,\n            'Root routes can only be used as the root of a route tree.',\n          )\n        } else {\n          invariant(\n            parentRoute ? route.parentRoute === parentRoute : true,\n            `Expected a route with path \"${route.path}\" to be passed to its parent route \"${route.parentRoute?.id}\" in an addChildren() call, but was instead passed as a child of the \"${parentRoute?.id}\" route.`,\n          )\n        }\n\n        if (route.children) {\n          recurceCheckRoutes(route.children as Route[], route)\n        }\n      })\n    }\n\n    recurceCheckRoutes([routeTree] as Route[], undefined)\n\n    return routeTree\n  }\n\n  #parseLocation = (previousLocation?: ParsedLocation): ParsedLocation => {\n    let { pathname, search, hash, state } = this.history.location\n\n    const parsedSearch = this.options.parseSearch(search)\n\n    return {\n      pathname: pathname,\n      searchStr: search,\n      search: replaceEqualDeep(previousLocation?.search, parsedSearch),\n      hash: hash.split('#').reverse()[0] ?? '',\n      href: `${pathname}${search}${hash}`,\n      state: state as LocationState,\n      key: state?.key || '__init__',\n    }\n  }\n\n  #buildLocation = (dest: BuildNextOptions = {}): ParsedLocation => {\n    dest.fromCurrent = dest.fromCurrent ?? dest.to === ''\n\n    const fromPathname = dest.fromCurrent\n      ? this.state.latestLocation.pathname\n      : dest.from ?? this.state.latestLocation.pathname\n\n    let pathname = resolvePath(\n      this.basepath ?? '/',\n      fromPathname,\n      `${dest.to ?? ''}`,\n    )\n\n    const fromMatches = this.matchRoutes(this.state.latestLocation.pathname, {\n      strictParseParams: true,\n    })\n\n    const prevParams = { ...last(fromMatches)?.params }\n\n    let nextParams =\n      (dest.params ?? true) === true\n        ? prevParams\n        : functionalUpdate(dest.params!, prevParams)\n\n    if (nextParams) {\n      dest.__matches\n        ?.map((d) => d.route.options.stringifyParams)\n        .filter(Boolean)\n        .forEach((fn) => {\n          nextParams = { ...nextParams!, ...fn!(nextParams!) }\n        })\n    }\n\n    pathname = interpolatePath(pathname, nextParams ?? {})\n\n    const preSearchFilters =\n      dest.__matches\n        ?.map((match) => match.route.options.preSearchFilters ?? [])\n        .flat()\n        .filter(Boolean) ?? []\n\n    const postSearchFilters =\n      dest.__matches\n        ?.map((match) => match.route.options.postSearchFilters ?? [])\n        .flat()\n        .filter(Boolean) ?? []\n\n    // Pre filters first\n    const preFilteredSearch = preSearchFilters?.length\n      ? preSearchFilters?.reduce(\n          (prev, next) => next(prev),\n          this.state.latestLocation.search,\n        )\n      : this.state.latestLocation.search\n\n    // Then the link/navigate function\n    const destSearch =\n      dest.search === true\n        ? preFilteredSearch // Preserve resolvedFrom true\n        : dest.search\n        ? functionalUpdate(dest.search, preFilteredSearch) ?? {} // Updater\n        : preSearchFilters?.length\n        ? preFilteredSearch // Preserve resolvedFrom filters\n        : {}\n\n    // Then post filters\n    const postFilteredSearch = postSearchFilters?.length\n      ? postSearchFilters.reduce((prev, next) => next(prev), destSearch)\n      : destSearch\n\n    const search = replaceEqualDeep(\n      this.state.latestLocation.search,\n      postFilteredSearch,\n    )\n\n    const searchStr = this.options.stringifySearch(search)\n    let hash =\n      dest.hash === true\n        ? this.state.latestLocation.hash\n        : functionalUpdate(dest.hash!, this.state.latestLocation.hash)\n    hash = hash ? `#${hash}` : ''\n\n    const nextState =\n      dest.state === true\n        ? this.state.latestLocation.state\n        : functionalUpdate(dest.state, this.state.latestLocation.state)!\n\n    return {\n      pathname,\n      search,\n      searchStr,\n      state: nextState,\n      hash,\n      href: this.history.createHref(`${pathname}${searchStr}${hash}`),\n      key: dest.key,\n    }\n  }\n\n  #commitLocation = async (\n    location: BuildNextOptions & { replace?: boolean },\n  ) => {\n    const next = this.buildNext(location)\n    const id = '' + Date.now() + Math.random()\n\n    if (this.navigateTimeout) clearTimeout(this.navigateTimeout)\n\n    let nextAction: 'push' | 'replace' = 'replace'\n\n    if (!location.replace) {\n      nextAction = 'push'\n    }\n\n    const isSameUrl = this.state.latestLocation.href === next.href\n\n    if (isSameUrl && !next.key) {\n      nextAction = 'replace'\n    }\n\n    const href = `${next.pathname}${next.searchStr}${\n      next.hash ? `${next.hash}` : ''\n    }`\n\n    this.history[nextAction === 'push' ? 'push' : 'replace'](href, {\n      id,\n      ...next.state,\n    })\n\n    return (this.navigationPromise = new Promise((resolve) => {\n      const previousNavigationResolve = this.resolveNavigation\n\n      this.resolveNavigation = () => {\n        previousNavigationResolve()\n        resolve()\n      }\n    }))\n  }\n}\n\n// Detect if we're in the DOM\nconst isServer = typeof window === 'undefined' || !window.document.createElement\n\nfunction getInitialRouterState(): RouterStore<any, any> {\n  return {\n    status: 'idle',\n    latestLocation: null!,\n    currentLocation: null!,\n    currentMatches: [],\n    lastUpdated: Date.now(),\n  }\n}\n\nfunction isCtrlEvent(e: MouseEvent) {\n  return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey)\n}\n\nexport type AnyRedirect = Redirect<any, any, any>\n\nexport type Redirect<\n  TRoutesInfo extends AnyRoutesInfo = RegisteredRoutesInfo,\n  TFrom extends TRoutesInfo['routePaths'] = '/',\n  TTo extends string = '',\n> = NavigateOptions<TRoutesInfo, TFrom, TTo> & {\n  code?: number\n}\n\nexport function redirect<\n  TRoutesInfo extends AnyRoutesInfo = RegisteredRoutesInfo,\n  TFrom extends TRoutesInfo['routePaths'] = '/',\n  TTo extends string = '',\n>(opts: Redirect<TRoutesInfo, TFrom, TTo>): Redirect<TRoutesInfo, TFrom, TTo> {\n  ;(opts as any).isRedirect = true\n  return opts\n}\n\nexport function isRedirect(obj: any): obj is AnyRedirect {\n  return !!obj?.isRedirect\n}\n","import { Store } from '@tanstack/store'\n//\nimport { GetFrameworkGeneric } from './frameworks'\nimport { AnyRoute, AnySearchSchema, Route } from './route'\nimport { AnyRoutesInfo, DefaultRoutesInfo } from './routeInfo'\nimport { AnyRouter, isRedirect, ParsedLocation, Router } from './router'\nimport { Expand, pick, replaceEqualDeep } from './utils'\n\nexport interface RouteMatchStore<\n  TRoutesInfo extends AnyRoutesInfo = DefaultRoutesInfo,\n  TRoute extends AnyRoute = Route,\n> {\n  routeSearch: TRoute['__types']['searchSchema']\n  search: TRoutesInfo['fullSearchSchema'] &\n    TRoute['__types']['fullSearchSchema']\n  status: 'idle' | 'pending' | 'success' | 'error'\n  error?: unknown\n  updatedAt: number\n}\n\nconst componentTypes = [\n  'component',\n  'errorComponent',\n  'pendingComponent',\n] as const\n\nexport interface PendingRouteMatchInfo {\n  state: RouteMatchStore<any, any>\n  routeContext: {}\n  context: {}\n}\n\nexport interface AnyRouteMatch extends RouteMatch<any, any> {}\n\nexport class RouteMatch<\n  TRoutesInfo extends AnyRoutesInfo = DefaultRoutesInfo,\n  TRoute extends AnyRoute = AnyRoute,\n> {\n  route!: TRoute\n  router!: Router<TRoutesInfo['routeTree'], TRoutesInfo>\n  __store!: Store<RouteMatchStore<TRoutesInfo, TRoute>>\n  state!: RouteMatchStore<TRoutesInfo, TRoute>\n  id!: string\n  pathname!: string\n  params!: TRoute['__types']['allParams']\n\n  routeContext?: TRoute['__types']['routeContext']\n  context?: TRoute['__types']['context']\n\n  component?: GetFrameworkGeneric<'Component'>\n  errorComponent?: GetFrameworkGeneric<'ErrorComponent'>\n  pendingComponent?: GetFrameworkGeneric<'Component'>\n  abortController = new AbortController()\n  parentMatch?: RouteMatch\n  pendingInfo?: PendingRouteMatchInfo\n\n  __loadPromise?: Promise<void>\n  __onExit?:\n    | void\n    | ((matchContext: {\n        params: TRoute['__types']['allParams']\n        search: TRoute['__types']['fullSearchSchema']\n      }) => void)\n\n  constructor(\n    router: AnyRouter,\n    route: TRoute,\n    opts: {\n      id: string\n      params: TRoute['__types']['allParams']\n      pathname: string\n    },\n  ) {\n    Object.assign(this, {\n      route,\n      router,\n      id: opts.id,\n      pathname: opts.pathname,\n      params: opts.params,\n      __store: new Store<RouteMatchStore<TRoutesInfo, TRoute>>(\n        {\n          updatedAt: 0,\n          routeSearch: {},\n          search: {} as any,\n          status: 'idle',\n        },\n        {\n          onUpdate: (next) => {\n            this.state = next\n          },\n        },\n      ),\n    })\n\n    this.state = this.__store.state\n\n    componentTypes.map(async (type) => {\n      const component = this.route.options[type]\n\n      if (typeof this[type] !== 'function') {\n        this[type] = component\n      }\n    })\n\n    if (this.state.status === 'idle' && !this.#hasLoaders()) {\n      this.__store.setState((s) => ({\n        ...s,\n        status: 'success',\n      }))\n    }\n  }\n\n  #hasLoaders = () => {\n    return !!(\n      this.route.options.onLoad ||\n      componentTypes.some((d) => this.route.options[d]?.preload)\n    )\n  }\n\n  __commit = () => {\n    const { routeSearch, search, context, routeContext } = this.#resolveInfo({\n      location: this.router.state.currentLocation,\n    })\n    this.context = context\n    this.routeContext = routeContext\n    this.__store.setState((s) => ({\n      ...s,\n      routeSearch: replaceEqualDeep(s.routeSearch, routeSearch),\n      search: replaceEqualDeep(s.search, search),\n    }))\n  }\n\n  cancel = () => {\n    this.abortController?.abort()\n  }\n\n  #resolveSearchInfo = (opts: {\n    location: ParsedLocation\n  }): { routeSearch: {}; search: {} } => {\n    // Validate the search params and stabilize them\n    const parentSearchInfo = this.parentMatch\n      ? this.parentMatch.#resolveSearchInfo(opts)\n      : { search: opts.location.search, routeSearch: opts.location.search }\n\n    try {\n      const validator =\n        typeof this.route.options.validateSearch === 'object'\n          ? this.route.options.validateSearch.parse\n          : this.route.options.validateSearch\n\n      const routeSearch = validator?.(parentSearchInfo.search) ?? {}\n\n      const search = {\n        ...parentSearchInfo.search,\n        ...routeSearch,\n      }\n\n      return {\n        routeSearch,\n        search,\n      }\n    } catch (err: any) {\n      if (isRedirect(err)) {\n        throw err\n      }\n\n      const errorHandler = this.route.options.onValidateSearchError ?? this.route.options.onError\n      errorHandler?.(err)\n      const error = new (Error as any)('Invalid search params found', {\n        cause: err,\n      })\n      error.code = 'INVALID_SEARCH_PARAMS'\n\n      throw error\n    }\n  }\n\n  #resolveInfo = (opts: { location: ParsedLocation }) => {\n    const { search, routeSearch } = this.#resolveSearchInfo(opts)\n\n    try {\n      const routeContext =\n        this.route.options.getContext?.({\n          parentContext: this.parentMatch?.routeContext ?? {},\n          context:\n            this.parentMatch?.context ?? this.router?.options.context ?? {},\n          params: this.params,\n          search,\n        }) || ({} as any)\n\n        const context = {\n          ...(this.parentMatch?.context ?? this.router?.options.context),\n          ...routeContext,\n        } as any\n    \n        return {\n          routeSearch,\n          search,\n          context,\n          routeContext,\n        }\n    } catch (err) {\n      this.route.options.onError?.(err)\n      throw err\n    }\n  }\n\n  __load = async (opts: {\n    parentMatch: RouteMatch | undefined\n    preload?: boolean\n    location: ParsedLocation\n  }): Promise<void> => {\n    this.parentMatch = opts.parentMatch\n\n    let info\n\n    try {\n      info = this.#resolveInfo(opts)\n    } catch (err) {\n      if (isRedirect(err)) {\n        if (!opts?.preload) {\n          this.router.navigate(err as any)\n        }\n        return\n      }\n\n      this.__store.setState((s) => ({\n        ...s,\n        status: 'error',\n        error: err,\n      }))\n\n      // Do not proceed with loading the route\n      return\n    }\n\n    const { routeSearch, search, context, routeContext } = info\n\n    // If the match is invalid, errored or idle, trigger it to load\n    if (this.state.status === 'pending') {\n      return\n    }\n\n    // TODO: Should load promises be tracked based on location?\n    this.__loadPromise = Promise.resolve().then(async () => {\n      const loadId = '' + Date.now() + Math.random()\n      this.#latestId = loadId\n\n      const checkLatest = () => {\n        return loadId !== this.#latestId ? this.__loadPromise : undefined\n      }\n\n      let latestPromise\n\n      // If the match was in an error state, set it\n      // to a loading state again. Otherwise, keep it\n      // as loading or resolved\n      if (this.state.status === 'idle') {\n        this.__store.setState((s) => ({\n          ...s,\n          status: 'pending',\n        }))\n      }\n\n      const componentsPromise = (async () => {\n        // then run all component and data loaders in parallel\n        // For each component type, potentially load it asynchronously\n\n        await Promise.all(\n          componentTypes.map(async (type) => {\n            const component = this.route.options[type]\n\n            if (this[type]?.preload) {\n              this[type] = await this.router.options.loadComponent!(component)\n            }\n          }),\n        )\n      })()\n\n      const dataPromise = Promise.resolve().then(() => {\n        if (this.route.options.onLoad) {\n          return this.route.options.onLoad({\n            params: this.params,\n            routeSearch,\n            search,\n            signal: this.abortController.signal,\n            preload: !!opts?.preload,\n            routeContext: routeContext,\n            context: context,\n          })\n        }\n        return\n      })\n\n      try {\n        await Promise.all([componentsPromise, dataPromise])\n        if ((latestPromise = checkLatest())) return await latestPromise\n        this.__store.setState((s) => ({\n          ...s,\n          error: undefined,\n          status: 'success',\n          updatedAt: Date.now(),\n        }))\n      } catch (err) {\n        if (isRedirect(err)) {\n          if (!opts?.preload) {\n            this.router.navigate(err as any)\n          }\n          return\n        }\n\n        const errorHandler = this.route.options.onLoadError ?? this.route.options.onError\n        try {\n          errorHandler?.(err)\n        } catch (errorHandlerErr) {\n          if (isRedirect(errorHandlerErr)) {\n            if (!opts?.preload) {\n              this.router.navigate(errorHandlerErr as any)\n            }\n            return\n          }\n\n          this.__store.setState((s) => ({\n            ...s,\n            error: errorHandlerErr,\n            status: 'error',\n            updatedAt: Date.now(),\n          }))\n          return\n        }\n\n        this.__store.setState((s) => ({\n          ...s,\n          error: err,\n          status: 'error',\n          updatedAt: Date.now(),\n        }))\n      } finally {\n        delete this.__loadPromise\n      }\n    })\n\n    return this.__loadPromise\n  }\n\n  #latestId = ''\n}\n","var isProduction = process.env.NODE_ENV === 'production';\nfunction warning(condition, message) {\n  if (!isProduction) {\n    if (condition) {\n      return;\n    }\n\n    var text = \"Warning: \" + message;\n\n    if (typeof console !== 'undefined') {\n      console.warn(text);\n    }\n\n    try {\n      throw Error(text);\n    } catch (x) {}\n  }\n}\n\nexport default warning;\n"],"names":["invariant","condition","message","Error","popStateEvent","beforeUnloadEvent","beforeUnloadListener","event","preventDefault","returnValue","stopBlocking","removeEventListener","capture","createHistory","opts","currentLocation","getLocation","unsub","listeners","Set","blockers","queue","tryFlush","length","shift","onUpdate","queueTask","task","push","forEach","listener","location","listen","cb","size","add","delete","path","state","pushState","replace","replaceState","go","index","back","forward","createHref","str","block","addEventListener","filter","b","createBrowserHistory","getHref","window","pathname","hash","search","parseLocation","history","key","createRandomKey","n","createMemoryHistory","initialEntries","entries","initialIndex","currentState","Math","min","href","hashIndex","indexOf","searchIndex","substring","random","toString","last","arr","functionalUpdate","updater","previous","pick","parent","keys","reduce","obj","replaceEqualDeep","prev","_next","next","array","Array","isArray","isPlainObject","prevSize","Object","nextItems","nextSize","copy","equalItems","i","o","hasObjectPrototype","ctor","constructor","prot","prototype","hasOwnProperty","call","partialDeepEqual","a","some","every","item","joinPaths","paths","cleanPath","Boolean","join","trimPathLeft","trimPathRight","trimPath","resolvePath","basepath","base","to","RegExp","baseSegments","parsePathname","toSegments","toSegment","value","pop","map","d","segments","slice","type","split","part","charAt","interpolatePath","params","leaveWildcard","segment","includes","matchPathname","currentPathname","matchLocation","pathParams","matchByPath","from","startsWith","routeSegments","max","baseSegment","routeSegment","isLastRouteSegment","isLastBaseSegment","caseSensitive","toLowerCase","fuzzy","undefined","encode","pfx","k","tmp","encodeURIComponent","toValue","mix","decodeURIComponent","decode","out","concat","rootRouteId","Route","options","this","isRoot","getParentRoute","init","originalIndex","router","allOptions","id","parentRoute","customId","fullPath","addChildren","children","RootRoute","super","static","Store","batching","initialState","subscribe","onSubscribe","setState","updateFn","flush","batch","defaultParseSearch","parseSearchWith","JSON","parse","defaultStringifySearch","stringifySearchWith","stringify","parser","searchStr","query","err","val","defaultFetchServerDataFn","async","routeMatch","buildNext","__data","matchId","res","fetch","method","signal","abortController","ok","json","isServer","document","createElement","getInitialRouterState","status","latestLocation","currentMatches","lastUpdated","Date","now","isRedirect","componentTypes","RouteMatch","AbortController","route","assign","__store","updatedAt","routeSearch","component","hasLoaders","s","onLoad","preload","__commit","context","routeContext","resolveInfo","cancel","abort","resolveSearchInfo","parentSearchInfo","parentMatch","validateSearch","onValidateSearchError","onError","error","cause","code","getContext","parentContext","__load","info","navigate","__loadPromise","Promise","resolve","then","loadId","latestId","checkLatest","latestPromise","componentsPromise","all","loadComponent","dataPromise","errorHandler","onLoadError","errorHandlerErr","unsubHistory","startedLoadingAt","resolveNavigation","defaultPreloadDelay","stringifySearch","parseSearch","fetchServerDataFn","update","Router","fromCurrent","commitLocation","reset","mount","safeLoad","parsedLocation","routeTree","routesById","buildRouteTree","buildLocation","__matches","matchRoutes","cancelMatches","pendingMatches","match","load","catch","console","warn","startedAt","matches","strictParseParams","pendingLocation","loadMatches","navigationPromise","previousMatches","exiting","staying","find","dd","entering","__onExit","onTransition","onLoaded","prevLocation","onRouteChange","getRoute","loadRoute","navigateOpts","preloadRoute","existingMatches","findInRouteTree","filteredRoutes","filterRoutes","routes","matchingRoutes","findMatchInRoutes","parentRoutes","matchParams","parsedParams","parseParams","foundRoute","interpolatedPath","foundChildren","resolvedMatches","firstBadMatchIndex","beforeLoad","onBeforeLoadError","validResolvedMatches","matchPromises","reload","String","fromString","isExternal","URL","e","matchRoute","baseLocation","pending","includeSearch","buildLink","target","activeOptions","preloadDelay","userPreloadDelay","disabled","nextOpts","defaultPreload","currentPathSplit","pathIsFuzzyEqual","pathTest","exact","hashTest","includeHash","searchTest","handleFocus","handleClick","metaKey","altKey","ctrlKey","shiftKey","isCtrlEvent","defaultPrevented","button","handleEnter","preloadTimeout","setTimeout","handleLeave","clearTimeout","handleTouchStart","isActive","dehydrate","hydrate","dehydratedRouter","dehydratedMatch","recurseRoutes","parsed","score","modifier","child","sort","recurceCheckRoutes","previousLocation","parsedSearch","reverse","dest","fromPathname","prevParams","nextParams","stringifyParams","fn","preSearchFilters","flat","postSearchFilters","preFilteredSearch","destSearch","postFilteredSearch","navigateTimeout","nextAction","previousNavigationResolve"],"mappings":"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"}