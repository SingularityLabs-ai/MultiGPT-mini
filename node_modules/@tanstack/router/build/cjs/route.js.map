{"version":3,"file":"route.js","sources":["../../src/route.ts"],"sourcesContent":["import { GetFrameworkGeneric } from './frameworks'\nimport { ParsePathParams } from './link'\nimport { RouteMatch } from './routeMatch'\nimport { AnyRouter, Router, RouterContext } from './router'\nimport {\n  IsAny,\n  NoInfer,\n  PickRequired,\n  PickUnsafe,\n  UnionToIntersection,\n} from './utils'\nimport invariant from 'tiny-invariant'\nimport { joinPaths, trimPath, trimPathRight } from './path'\nimport { DefaultRoutesInfo } from './routeInfo'\n\nexport const rootRouteId = '__root__' as const\nexport type RootRouteId = typeof rootRouteId\n\nexport type AnyPathParams = {}\nexport type AnySearchSchema = {}\nexport type AnyContext = {}\nexport interface RouteMeta {}\nexport interface RouteContext {}\n\nexport type RouteOptionsBase<TCustomId, TPath> =\n  | {\n      path: TPath\n    }\n  | {\n      id: TCustomId\n    }\n\nexport type RouteOptionsBaseIntersection<TCustomId, TPath> =\n  UnionToIntersection<RouteOptionsBase<TCustomId, TPath>>\n\nexport interface FrameworkRouteOptions {}\n\nexport type MetaOptions = keyof PickRequired<RouteMeta> extends never\n  ? {\n      meta?: RouteMeta\n    }\n  : {\n      meta: RouteMeta\n    }\n\ntype GetContextFn<\n  TParentRoute,\n  TAllParams,\n  TFullSearchSchema,\n  TParentContext,\n  TAllParentContext,\n  TRouteContext,\n> = (\n  opts: {\n    params: TAllParams\n    search: TFullSearchSchema\n  } & (TParentRoute extends undefined\n    ? {\n        context?: TAllParentContext\n        parentContext?: TParentContext\n      }\n    : {\n        context: TAllParentContext\n        parentContext: TParentContext\n      }),\n) => TRouteContext\n\nexport type ContextOptions<\n  TParentRoute,\n  TAllParams,\n  TFullSearchSchema,\n  TParentContext,\n  TAllParentContext,\n  TRouteContext,\n> = keyof PickRequired<RouteContext> extends never\n  ? {\n      getContext?: GetContextFn<\n        TParentRoute,\n        TAllParams,\n        TFullSearchSchema,\n        TParentContext,\n        TAllParentContext,\n        TRouteContext\n      >\n    }\n  : {\n      getContext: GetContextFn<\n        TParentRoute,\n        TAllParams,\n        TFullSearchSchema,\n        TParentContext,\n        TAllParentContext,\n        TRouteContext\n      >\n    }\n\nexport type RouteOptions<\n  TParentRoute extends AnyRoute = AnyRoute,\n  TCustomId extends string = string,\n  TPath extends string = string,\n  TParentSearchSchema extends {} = {},\n  TSearchSchema extends AnySearchSchema = {},\n  TFullSearchSchema extends AnySearchSchema = TSearchSchema,\n  TParentParams extends AnyPathParams = {},\n  TParams = Record<ParsePathParams<TPath>, string>,\n  TAllParams = TParams,\n  TParentContext extends AnyContext = AnyContext,\n  TAllParentContext extends AnyContext = AnyContext,\n  TRouteContext extends RouteContext = RouteContext,\n  TContext extends AnyContext = TRouteContext,\n> = RouteOptionsBase<TCustomId, TPath> &\n  FrameworkRouteOptions & {\n    getParentRoute: () => TParentRoute\n    // If true, this route will be matched as case-sensitive\n    caseSensitive?: boolean\n    // Filter functions that can manipulate search params *before* they are passed to links and navigate\n    // calls that match this route.\n    preSearchFilters?: SearchFilter<TFullSearchSchema>[]\n    // Filter functions that can manipulate search params *after* they are passed to links and navigate\n    // calls that match this route.\n    postSearchFilters?: SearchFilter<TFullSearchSchema>[]\n    // The content to be rendered when the route is matched. If no component is provided, defaults to `<Outlet />`\n    component?: GetFrameworkGeneric<'Component'> // , NoInfer<TParentAllLoaderData>>\n    // The content to be rendered when the route encounters an error\n    errorComponent?: GetFrameworkGeneric<'ErrorComponent'> // , NoInfer<TParentAllLoaderData>>\n    // If supported by your framework, the content to be rendered as the fallback content until the route is ready to render\n    pendingComponent?: GetFrameworkGeneric<'Component'> //, NoInfer<TParentAllLoaderData>>\n    // This async function is called before a route is loaded.\n    // If an error is thrown here, the route's loader will not be called.\n    // If thrown during a navigation, the navigation will be cancelled and the error will be passed to the `onLoadError` function.\n    // If thrown during a preload event, the error will be logged to the console.\n    beforeLoad?: (opts: {\n      router: AnyRouter\n      match: RouteMatch\n    }) => Promise<void> | void\n    // This function will be called if the route's loader throws an error **during an attempted navigation**.\n    // If you want to redirect due to an error, call `router.navigate()` from within this function.\n    onBeforeLoadError?: (err: any) => void\n    validateSearch?: SearchSchemaValidator<TSearchSchema, TParentSearchSchema>\n    // This function will be called if the route's validateSearch option throws an error **during an attempted validation**.\n    // If you want to redirect due to an error, call `router.navigate()` from within this function.\n    // If you want to display the errorComponent, rethrow the error\n    onValidateSearchError?: (err: any) => void\n    // An asynchronous function responsible for preparing or fetching data for the route before it is rendered\n    onLoad?: OnLoadFn<\n      TSearchSchema,\n      TFullSearchSchema,\n      TAllParams,\n      NoInfer<TRouteContext>,\n      TContext\n    >\n    onLoadError?: (err: any) => void\n    onError?: (err: any) => void\n    // This function is called\n    // when moving from an inactive state to an active one. Likewise, when moving from\n    // an active to an inactive state, the return function (if provided) is called.\n    onLoaded?: (matchContext: {\n      params: TAllParams\n      search: TFullSearchSchema\n    }) =>\n      | void\n      | undefined\n      | ((match: { params: TAllParams; search: TFullSearchSchema }) => void)\n    // This function is called when the route remains active from one transition to the next.\n    onTransition?: (match: {\n      params: TAllParams\n      search: TFullSearchSchema\n    }) => void\n  } & MetaOptions &\n  ContextOptions<\n    TParentRoute,\n    TAllParams,\n    TFullSearchSchema,\n    TParentContext,\n    TAllParentContext,\n    TRouteContext\n  > &\n  (\n    | {\n        // Parse params optionally receives path params as strings and returns them in a parsed format (like a number or boolean)\n        parseParams?: (\n          rawParams: IsAny<TPath, any, Record<ParsePathParams<TPath>, string>>,\n        ) => TParams extends Record<ParsePathParams<TPath>, any>\n          ? TParams\n          : 'parseParams must return an ojbect'\n        stringifyParams?: (\n          params: NoInfer<TParams>,\n        ) => Record<ParsePathParams<TPath>, string>\n      }\n    | {\n        stringifyParams?: never\n        parseParams?: never\n      }\n  ) &\n  (PickUnsafe<TParentParams, ParsePathParams<TPath>> extends never // Detect if an existing path param is being redefined\n    ? { test?: PickUnsafe<TParentParams, ParsePathParams<TPath>> }\n    : 'Cannot redefined path params in child routes!')\n\n// The parse type here allows a zod schema to be passed directly to the validator\nexport type SearchSchemaValidator<TReturn, TParentSchema> =\n  | SearchSchemaValidatorObj<TReturn, TParentSchema>\n  | SearchSchemaValidatorFn<TReturn, TParentSchema>\n\nexport type SearchSchemaValidatorObj<TReturn, TParentSchema> = {\n  parse?: SearchSchemaValidatorFn<TReturn, TParentSchema>\n}\n\nexport type SearchSchemaValidatorFn<TReturn, TParentSchema> = (\n  searchObj: Record<string, unknown>,\n) => {} extends TParentSchema\n  ? TReturn\n  : keyof TReturn extends keyof TParentSchema\n  ? {\n      error: 'Top level search params cannot be redefined by child routes!'\n      keys: keyof TReturn & keyof TParentSchema\n    }\n  : TReturn\n\nexport type DefinedPathParamWarning =\n  'Path params cannot be redefined by child routes!'\n\nexport type ParentParams<TParentParams> = AnyPathParams extends TParentParams\n  ? {}\n  : {\n      [Key in keyof TParentParams]?: DefinedPathParamWarning\n    }\n\nexport type OnLoadFn<\n  TSearchSchema extends AnySearchSchema = {},\n  TFullSearchSchema extends AnySearchSchema = {},\n  TAllParams = {},\n  TContext extends AnyContext = AnyContext,\n  TAllContext extends AnyContext = AnyContext,\n> = (\n  loaderContext: LoaderContext<\n    TSearchSchema,\n    TFullSearchSchema,\n    TAllParams,\n    TContext,\n    TAllContext\n  >,\n) => Promise<any> | void\n\nexport interface LoaderContext<\n  TSearchSchema extends AnySearchSchema = {},\n  TFullSearchSchema extends AnySearchSchema = {},\n  TAllParams = {},\n  TContext extends AnyContext = AnyContext,\n  TAllContext extends AnyContext = AnyContext,\n> {\n  params: TAllParams\n  routeSearch: TSearchSchema\n  search: TFullSearchSchema\n  signal?: AbortSignal\n  preload: boolean\n  routeContext: TContext\n  context: TAllContext\n}\n\nexport type UnloaderFn<TPath extends string> = (\n  routeMatch: RouteMatch<any, Route>,\n) => void\n\nexport type SearchFilter<T, U = T> = (prev: T) => U\n\ntype ResolveId<\n  TParentRoute,\n  TCustomId extends string,\n  TPath extends string,\n> = TParentRoute extends { id: infer TParentId extends string }\n  ? RoutePrefix<TParentId, string extends TCustomId ? TPath : TCustomId>\n  : RootRouteId\n\nexport type InferFullSearchSchema<TRoute> = TRoute extends {\n  isRoot: true\n  __types: {\n    searchSchema: infer TSearchSchema\n  }\n}\n  ? TSearchSchema\n  : TRoute extends {\n      __types: {\n        fullSearchSchema: infer TFullSearchSchema\n      }\n    }\n  ? TFullSearchSchema\n  : {}\n\nexport type ResolveFullSearchSchema<TParentRoute, TSearchSchema> =\n  InferFullSearchSchema<TParentRoute> & TSearchSchema\n\nexport interface AnyRoute\n  extends Route<\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any\n  > {}\n\ntype MergeFromParent<T, U> = IsAny<T, U, T & U>\n\nexport class Route<\n  TParentRoute extends AnyRoute = AnyRoute,\n  TPath extends string = string,\n  TFullPath extends ResolveFullPath<TParentRoute, TPath> = ResolveFullPath<\n    TParentRoute,\n    TPath\n  >,\n  TCustomId extends string = string,\n  TId extends ResolveId<TParentRoute, TCustomId, TPath> = ResolveId<\n    TParentRoute,\n    TCustomId,\n    TPath\n  >,\n  TSearchSchema extends AnySearchSchema = {},\n  TFullSearchSchema extends AnySearchSchema = ResolveFullSearchSchema<\n    TParentRoute,\n    TSearchSchema\n  >,\n  TParams extends Record<ParsePathParams<TPath>, any> = Record<\n    ParsePathParams<TPath>,\n    string\n  >,\n  TAllParams extends MergeFromParent<\n    TParentRoute['__types']['allParams'],\n    TParams\n  > = MergeFromParent<TParentRoute['__types']['allParams'], TParams>,\n  TParentContext extends TParentRoute['__types']['routeContext'] = TParentRoute['__types']['routeContext'],\n  TAllParentContext extends TParentRoute['__types']['context'] = TParentRoute['__types']['context'],\n  TRouteContext extends RouteContext = RouteContext,\n  TContext extends MergeFromParent<\n    TParentRoute['__types']['context'],\n    TRouteContext\n  > = MergeFromParent<TParentRoute['__types']['context'], TRouteContext>,\n  TRouterContext extends AnyContext = AnyContext,\n  TChildren extends unknown = unknown,\n  TRoutesInfo extends DefaultRoutesInfo = DefaultRoutesInfo,\n> {\n  __types!: {\n    parentRoute: TParentRoute\n    path: TPath\n    fullPath: TFullPath\n    customId: TCustomId\n    id: TId\n    searchSchema: TSearchSchema\n    fullSearchSchema: TFullSearchSchema\n    params: TParams\n    allParams: TAllParams\n    parentContext: TParentContext\n    allParentContext: TAllParentContext\n    routeContext: TRouteContext\n    context: TContext\n    children: TChildren\n    routesInfo: TRoutesInfo\n    routerContext: TRouterContext\n  }\n  isRoot: TParentRoute extends Route<any> ? true : false\n  options: RouteOptions<\n    TParentRoute,\n    TCustomId,\n    TPath,\n    InferFullSearchSchema<TParentRoute>,\n    TSearchSchema,\n    InferFullSearchSchema<TParentRoute> & TSearchSchema,\n    TParentRoute['__types']['allParams'],\n    TParams,\n    TAllParams,\n    TParentContext,\n    TAllParentContext,\n    TRouteContext,\n    TContext\n  >\n\n  // Set up in this.init()\n  parentRoute!: TParentRoute\n  id!: TId\n  // customId!: TCustomId\n  path!: TPath\n  fullPath!: TFullPath\n\n  // Optional\n  children?: TChildren\n  originalIndex?: number\n  router?: Router<TRoutesInfo['routeTree'], TRoutesInfo>\n\n  constructor(\n    options: RouteOptions<\n      TParentRoute,\n      TCustomId,\n      TPath,\n      InferFullSearchSchema<TParentRoute>,\n      TSearchSchema,\n      TFullSearchSchema,\n      TParentRoute['__types']['allParams'],\n      TParams,\n      TAllParams,\n      TParentContext,\n      TAllParentContext,\n      TRouteContext,\n      TContext\n    >,\n  ) {\n    this.options = (options as any) || {}\n    this.isRoot = !options?.getParentRoute as any\n  }\n\n  init = (opts: { originalIndex: number; router: AnyRouter }) => {\n    this.originalIndex = opts.originalIndex\n    this.router = opts.router\n\n    const allOptions = this.options as RouteOptions<\n      TParentRoute,\n      TCustomId,\n      TPath,\n      InferFullSearchSchema<TParentRoute>,\n      TSearchSchema,\n      TFullSearchSchema,\n      TParentRoute['__types']['allParams'],\n      TParams,\n      TAllParams,\n      TParentContext,\n      TAllParentContext,\n      TRouteContext,\n      TContext\n    > &\n      RouteOptionsBaseIntersection<TCustomId, TPath>\n\n    const isRoot = !allOptions?.path && !allOptions?.id\n\n    this.parentRoute = this.options?.getParentRoute?.()\n\n    if (isRoot) {\n      this.path = rootRouteId as TPath\n    } else {\n      invariant(\n        this.parentRoute,\n        `Child Route instances must pass a 'getParentRoute: () => ParentRoute' option that returns a Route instance.`,\n      )\n    }\n\n    let path: undefined | string = isRoot ? rootRouteId : allOptions.path\n\n    // If the path is anything other than an index path, trim it up\n    if (path && path !== '/') {\n      path = trimPath(path)\n    }\n\n    const customId = allOptions?.id || path\n\n    // Strip the parentId prefix from the first level of children\n    let id = isRoot\n      ? rootRouteId\n      : joinPaths([\n          (this.parentRoute.id as any) === rootRouteId\n            ? ''\n            : this.parentRoute.id,\n          customId,\n        ])\n\n    if (path === rootRouteId) {\n      path = '/'\n    }\n\n    if (id !== rootRouteId) {\n      id = joinPaths(['/', id])\n    }\n\n    const fullPath =\n      id === rootRouteId\n        ? '/'\n        : trimPathRight(joinPaths([this.parentRoute.fullPath, path]))\n\n    this.path = path as TPath\n    this.id = id as TId\n    // this.customId = customId as TCustomId\n    this.fullPath = fullPath as TFullPath\n  }\n\n  addChildren = <TNewChildren extends AnyRoute[]>(\n    children: TNewChildren,\n  ): Route<\n    TParentRoute,\n    TPath,\n    TFullPath,\n    TCustomId,\n    TId,\n    TSearchSchema,\n    TFullSearchSchema,\n    TParams,\n    TAllParams,\n    TParentContext,\n    TAllParentContext,\n    TRouteContext,\n    TContext,\n    TRouterContext,\n    TNewChildren,\n    TRoutesInfo\n  > => {\n    this.children = children as any\n    return this as any\n  }\n\n  // generate = (\n  //   options: Omit<\n  //     RouteOptions<\n  //       TParentRoute,\n  //       TCustomId,\n  //       TPath,\n  //       InferFullSearchSchema<TParentRoute>,\n  //       TSearchSchema,\n  //       TFullSearchSchema,\n  //       TParentRoute['__types']['allParams'],\n  //       TParams,\n  //       TAllParams,\n  //       TParentContext,\n  //       TAllParentContext,\n  //       TRouteContext,\n  //       TContext\n  //     >,\n  //     'path'\n  //   >,\n  // ) => {\n  //   invariant(\n  //     false,\n  //     `route.generate() is used by TanStack Router's file-based routing code generation and should not actually be called during runtime. `,\n  //   )\n  // }\n}\n\nexport type AnyRootRoute = RootRoute<any, any, any>\n\nexport class RootRoute<\n  TSearchSchema extends AnySearchSchema = {},\n  TContext extends RouteContext = RouteContext,\n  TRouterContext extends RouterContext = RouterContext,\n> extends Route<\n  any,\n  '/',\n  '/',\n  string,\n  RootRouteId,\n  TSearchSchema,\n  TSearchSchema,\n  {},\n  {},\n  TRouterContext,\n  TRouterContext,\n  TContext,\n  MergeFromParent<TRouterContext, TContext>,\n  TRouterContext\n> {\n  constructor(\n    options?: Omit<\n      RouteOptions<\n        AnyRoute,\n        RootRouteId,\n        '',\n        {},\n        TSearchSchema,\n        NoInfer<TSearchSchema>,\n        {},\n        TRouterContext,\n        TRouterContext,\n        TContext,\n        NoInfer<TContext>\n      >,\n      | 'path'\n      | 'id'\n      | 'getParentRoute'\n      | 'caseSensitive'\n      | 'parseParams'\n      | 'stringifyParams'\n    >,\n  ) {\n    super(options as any)\n  }\n\n  static withRouterContext = <TRouterContext extends RouterContext>() => {\n    return <\n      TSearchSchema extends AnySearchSchema = {},\n      TContext extends RouterContext = RouterContext,\n    >(\n      options?: Omit<\n        RouteOptions<\n          AnyRoute,\n          RootRouteId,\n          '',\n          {},\n          TSearchSchema,\n          NoInfer<TSearchSchema>,\n          {},\n          TRouterContext,\n          TRouterContext,\n          TContext,\n          TRouterContext & TContext\n        >,\n        'path' | 'id' | 'getParentRoute' | 'caseSensitive'\n      >,\n    ) => new RootRoute<TSearchSchema, TContext, TRouterContext>(options as any)\n  }\n}\n\ntype ResolveFullPath<\n  TParentRoute extends AnyRoute,\n  TPath extends string,\n  TPrefixed extends RoutePrefix<TParentRoute['fullPath'], TPath> = RoutePrefix<\n    TParentRoute['fullPath'],\n    TPath\n  >,\n> = TPrefixed extends RootRouteId ? '/' : TrimPathRight<`${TPrefixed}`>\n\ntype RoutePrefix<\n  TPrefix extends string,\n  TId extends string,\n> = string extends TId\n  ? RootRouteId\n  : TId extends string\n  ? TPrefix extends RootRouteId\n    ? TId extends '/'\n      ? '/'\n      : `/${TrimPath<TId>}`\n    : `${TPrefix}/${TId}` extends '/'\n    ? '/'\n    : `/${TrimPathLeft<`${TrimPathRight<TPrefix>}/${TrimPath<TId>}`>}`\n  : never\n\ntype TrimPath<T extends string> = '' extends T\n  ? ''\n  : TrimPathRight<TrimPathLeft<T>>\n\ntype TrimPathLeft<T extends string> = T extends `${RootRouteId}/${infer U}`\n  ? TrimPathLeft<U>\n  : T extends `/${infer U}`\n  ? TrimPathLeft<U>\n  : T\ntype TrimPathRight<T extends string> = T extends '/'\n  ? '/'\n  : T extends `${infer U}/`\n  ? TrimPathRight<U>\n  : T\n\n// const rootRoute = new RootRoute({\n//   validateSearch: () => null as unknown as { root?: boolean },\n// })\n\n// const aRoute = new Route({\n//   getParentRoute: () => rootRoute,\n//   path: 'a',\n//   validateSearch: () => null as unknown as { a?: string },\n// })\n\n// const bRoute = new Route({\n//   getParentRoute: () => aRoute,\n//   path: 'b',\n// })\n\n// const rootIsRoot = rootRoute.isRoot\n// //    ^?\n// const aIsRoot = aRoute.isRoot\n// //    ^?\n\n// const rId = rootRoute.id\n// //    ^?\n// const aId = aRoute.id\n// //    ^?\n// const bId = bRoute.id\n// //    ^?\n\n// const rPath = rootRoute.fullPath\n// //    ^?\n// const aPath = aRoute.fullPath\n// //    ^?\n// const bPath = bRoute.fullPath\n// //    ^?\n\n// const rSearch = rootRoute.__types.fullSearchSchema\n// //    ^?\n// const aSearch = aRoute.__types.fullSearchSchema\n// //    ^?\n// const bSearch = bRoute.__types.fullSearchSchema\n// //    ^?\n\n// const config = rootRoute.addChildren([aRoute.addChildren([bRoute])])\n// //    ^?\n"],"names":["rootRouteId","Route","constructor","options","isRoot","getParentRoute","init","opts","originalIndex","router","allOptions","path","id","parentRoute","invariant","trimPath","customId","joinPaths","fullPath","trimPathRight","addChildren","children","RootRoute","withRouterContext"],"mappings":"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"}