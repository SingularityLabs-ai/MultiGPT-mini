{"version":3,"file":"path.js","sources":["../../src/path.ts"],"sourcesContent":["import invariant from 'tiny-invariant'\nimport { AnyPathParams } from './route'\nimport { MatchLocation } from './router'\nimport { last } from './utils'\n\nexport interface Segment {\n  type: 'pathname' | 'param' | 'wildcard'\n  value: string\n}\n\nexport function joinPaths(paths: (string | undefined)[]) {\n  return cleanPath(paths.filter(Boolean).join('/'))\n}\n\nexport function cleanPath(path: string) {\n  // remove double slashes\n  return path.replace(/\\/{2,}/g, '/')\n}\n\nexport function trimPathLeft(path: string) {\n  return path === '/' ? path : path.replace(/^\\/{1,}/, '')\n}\n\nexport function trimPathRight(path: string) {\n  return path === '/' ? path : path.replace(/\\/{1,}$/, '')\n}\n\nexport function trimPath(path: string) {\n  return trimPathRight(trimPathLeft(path))\n}\n\nexport function resolvePath(basepath: string, base: string, to: string) {\n  base = base.replace(new RegExp(`^${basepath}`), '/')\n  to = to.replace(new RegExp(`^${basepath}`), '/')\n\n  let baseSegments = parsePathname(base)\n  const toSegments = parsePathname(to)\n\n  toSegments.forEach((toSegment, index) => {\n    if (toSegment.value === '/') {\n      if (!index) {\n        // Leading slash\n        baseSegments = [toSegment]\n      } else if (index === toSegments.length - 1) {\n        // Trailing Slash\n        baseSegments.push(toSegment)\n      } else {\n        // ignore inter-slashes\n      }\n    } else if (toSegment.value === '..') {\n      // Extra trailing slash? pop it off\n      if (baseSegments.length > 1 && last(baseSegments)?.value === '/') {\n        baseSegments.pop()\n      }\n      baseSegments.pop()\n    } else if (toSegment.value === '.') {\n      return\n    } else {\n      baseSegments.push(toSegment)\n    }\n  })\n\n  const joined = joinPaths([basepath, ...baseSegments.map((d) => d.value)])\n\n  return cleanPath(joined)\n}\n\nexport function parsePathname(pathname?: string): Segment[] {\n  if (!pathname) {\n    return []\n  }\n\n  pathname = cleanPath(pathname)\n\n  const segments: Segment[] = []\n\n  if (pathname.slice(0, 1) === '/') {\n    pathname = pathname.substring(1)\n    segments.push({\n      type: 'pathname',\n      value: '/',\n    })\n  }\n\n  if (!pathname) {\n    return segments\n  }\n\n  // Remove empty segments and '.' segments\n  const split = pathname.split('/').filter(Boolean)\n\n  segments.push(\n    ...split.map((part): Segment => {\n      if (part === '$' || part === '*') {\n        return {\n          type: 'wildcard',\n          value: part,\n        }\n      }\n\n      if (part.charAt(0) === '$') {\n        return {\n          type: 'param',\n          value: part,\n        }\n      }\n\n      return {\n        type: 'pathname',\n        value: part,\n      }\n    }),\n  )\n\n  if (pathname.slice(-1) === '/') {\n    pathname = pathname.substring(1)\n    segments.push({\n      type: 'pathname',\n      value: '/',\n    })\n  }\n\n  return segments\n}\n\nexport function interpolatePath(\n  path: string | undefined,\n  params: any,\n  leaveWildcard?: boolean,\n) {\n  const interpolatedPathSegments = parsePathname(path)\n\n  return joinPaths(\n    interpolatedPathSegments.map((segment) => {\n      if (['$', '*'].includes(segment.value) && !leaveWildcard) {\n        return ''\n      }\n\n      if (segment.type === 'param') {\n        return params![segment.value.substring(1)] ?? ''\n      }\n\n      return segment.value\n    }),\n  )\n}\n\nexport function matchPathname(\n  basepath: string,\n  currentPathname: string,\n  matchLocation: Pick<MatchLocation, 'to' | 'fuzzy' | 'caseSensitive'>,\n): AnyPathParams | undefined {\n  const pathParams = matchByPath(basepath, currentPathname, matchLocation)\n  // const searchMatched = matchBySearch(currentLocation.search, matchLocation)\n\n  if (matchLocation.to && !pathParams) {\n    return\n  }\n\n  return pathParams ?? {}\n}\n\nexport function matchByPath(\n  basepath: string,\n  from: string,\n  matchLocation: Pick<MatchLocation, 'to' | 'caseSensitive' | 'fuzzy'>,\n): Record<string, string> | undefined {\n  if (!from.startsWith(basepath)) {\n    return undefined\n  }\n  from = basepath != '/' ? from.substring(basepath.length) : from\n  const baseSegments = parsePathname(from)\n  const to = `${matchLocation.to ?? '$'}`\n  const routeSegments = parsePathname(to)\n\n  if (last(baseSegments)?.value === '/') {\n    baseSegments.pop()\n  }\n\n  const params: Record<string, string> = {}\n\n  let isMatch = (() => {\n    for (\n      let i = 0;\n      i < Math.max(baseSegments.length, routeSegments.length);\n      i++\n    ) {\n      const baseSegment = baseSegments[i]\n      const routeSegment = routeSegments[i]\n\n      const isLastRouteSegment = i === routeSegments.length - 1\n      const isLastBaseSegment = i === baseSegments.length - 1\n\n      if (routeSegment) {\n        if (routeSegment.type === 'wildcard') {\n          if (baseSegment?.value) {\n            params['*'] = joinPaths(baseSegments.slice(i).map((d) => d.value))\n            return true\n          }\n          return false\n        }\n\n        if (routeSegment.type === 'pathname') {\n          if (routeSegment.value === '/' && !baseSegment?.value) {\n            return true\n          }\n\n          if (baseSegment) {\n            if (matchLocation.caseSensitive) {\n              if (routeSegment.value !== baseSegment.value) {\n                return false\n              }\n            } else if (\n              routeSegment.value.toLowerCase() !==\n              baseSegment.value.toLowerCase()\n            ) {\n              return false\n            }\n          }\n        }\n\n        if (!baseSegment) {\n          return false\n        }\n\n        if (routeSegment.type === 'param') {\n          if (baseSegment?.value === '/') {\n            return false\n          }\n          if (baseSegment.value.charAt(0) !== '$') {\n            params[routeSegment.value.substring(1)] = baseSegment.value\n          }\n        }\n      }\n\n      if (isLastRouteSegment && !isLastBaseSegment) {\n        return !!matchLocation.fuzzy\n      }\n    }\n    return true\n  })()\n\n  return isMatch ? (params as Record<string, string>) : undefined\n}\n"],"names":["joinPaths","paths","cleanPath","filter","Boolean","join","path","replace","trimPathLeft","trimPathRight","trimPath","resolvePath","basepath","base","to","RegExp","baseSegments","parsePathname","toSegments","forEach","toSegment","index","value","length","push","last","pop","joined","map","d","pathname","segments","slice","substring","type","split","part","charAt","interpolatePath","params","leaveWildcard","interpolatedPathSegments","segment","includes","matchPathname","currentPathname","matchLocation","pathParams","matchByPath","from","startsWith","undefined","routeSegments","isMatch","i","Math","max","baseSegment","routeSegment","isLastRouteSegment","isLastBaseSegment","caseSensitive","toLowerCase","fuzzy"],"mappings":"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"}