{"version":3,"file":"multiplexed.js","sources":["../../../src/transports/multiplexed.ts"],"sourcesContent":["import type {\n  BaseTransportOptions,\n  Envelope,\n  EnvelopeItemType,\n  Event,\n  EventItem,\n  Transport,\n  TransportMakeRequestResponse,\n} from '@sentry/types';\nimport { dsnFromString, forEachEnvelopeItem } from '@sentry/utils';\n\nimport { getEnvelopeEndpointWithUrlEncodedAuth } from '../api';\n\ninterface MatchParam {\n  /** The envelope to be sent */\n  envelope: Envelope;\n  /**\n   * A function that returns an event from the envelope if one exists. You can optionally pass an array of envelope item\n   * types to filter by - only envelopes matching the given types will be multiplexed.\n   * Allowed values are: 'event', 'transaction', 'profile', 'replay_event'\n   *\n   * @param types Defaults to ['event']\n   */\n  getEvent(types?: EnvelopeItemType[]): Event | undefined;\n}\n\ntype Matcher = (param: MatchParam) => string[];\n\nfunction eventFromEnvelope(env: Envelope, types: EnvelopeItemType[]): Event | undefined {\n  let event: Event | undefined;\n\n  forEachEnvelopeItem(env, (item, type) => {\n    if (types.includes(type)) {\n      event = Array.isArray(item) ? (item as EventItem)[1] : undefined;\n    }\n    // bail out if we found an event\n    return !!event;\n  });\n\n  return event;\n}\n\n/**\n * Creates a transport that can send events to different DSNs depending on the envelope contents.\n */\nexport function makeMultiplexedTransport<TO extends BaseTransportOptions>(\n  createTransport: (options: TO) => Transport,\n  matcher: Matcher,\n): (options: TO) => Transport {\n  return options => {\n    const fallbackTransport = createTransport(options);\n    const otherTransports: Record<string, Transport> = {};\n\n    function getTransport(dsn: string): Transport | undefined {\n      if (!otherTransports[dsn]) {\n        const validatedDsn = dsnFromString(dsn);\n        if (!validatedDsn) {\n          return undefined;\n        }\n        const url = getEnvelopeEndpointWithUrlEncodedAuth(validatedDsn);\n        otherTransports[dsn] = createTransport({ ...options, url });\n      }\n\n      return otherTransports[dsn];\n    }\n\n    async function send(envelope: Envelope): Promise<void | TransportMakeRequestResponse> {\n      function getEvent(types?: EnvelopeItemType[]): Event | undefined {\n        const eventTypes: EnvelopeItemType[] = types && types.length ? types : ['event'];\n        return eventFromEnvelope(envelope, eventTypes);\n      }\n\n      const transports = matcher({ envelope, getEvent })\n        .map(dsn => getTransport(dsn))\n        .filter((t): t is Transport => !!t);\n\n      // If we have no transports to send to, use the fallback transport\n      if (transports.length === 0) {\n        transports.push(fallbackTransport);\n      }\n\n      const results = await Promise.all(transports.map(transport => transport.send(envelope)));\n\n      return results[0];\n    }\n\n    async function flush(timeout: number | undefined): Promise<boolean> {\n      const allTransports = [...Object.keys(otherTransports).map(dsn => otherTransports[dsn]), fallbackTransport];\n      const results = await Promise.all(allTransports.map(transport => transport.flush(timeout)));\n      return results.every(r => r);\n    }\n\n    return {\n      send,\n      flush,\n    };\n  };\n}\n"],"names":[],"mappings":"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"}