{"version":3,"file":"hubextensions.js","sources":["../../../../src/profiling/hubextensions.ts"],"sourcesContent":["import { getCurrentHub, getMainCarrier } from '@sentry/core';\nimport type { CustomSamplingContext, Hub, Transaction, TransactionContext } from '@sentry/types';\nimport { logger, uuid4 } from '@sentry/utils';\n\nimport { WINDOW } from '../helpers';\nimport type {\n  JSSelfProfile,\n  JSSelfProfiler,\n  JSSelfProfilerConstructor,\n  ProcessedJSSelfProfile,\n} from './jsSelfProfiling';\nimport { sendProfile } from './sendProfile';\n\n// Max profile duration.\nconst MAX_PROFILE_DURATION_MS = 30_000;\n// Keep a flag value to avoid re-initializing the profiler constructor. If it fails\n// once, it will always fail and this allows us to early return.\nlet PROFILING_CONSTRUCTOR_FAILED = false;\n\n// While we experiment, per transaction sampling interval will be more flexible to work with.\ntype StartTransaction = (\n  this: Hub,\n  transactionContext: TransactionContext,\n  customSamplingContext?: CustomSamplingContext,\n) => Transaction | undefined;\n\n/**\n * Check if profiler constructor is available.\n * @param maybeProfiler\n */\nfunction isJSProfilerSupported(maybeProfiler: unknown): maybeProfiler is typeof JSSelfProfilerConstructor {\n  return typeof maybeProfiler === 'function';\n}\n\n/**\n * Safety wrapper for startTransaction for the unlikely case that transaction starts before tracing is imported -\n * if that happens we want to avoid throwing an error from profiling code.\n * see https://github.com/getsentry/sentry-javascript/issues/4731.\n *\n * @experimental\n */\nexport function onProfilingStartRouteTransaction(transaction: Transaction | undefined): Transaction | undefined {\n  if (!transaction) {\n    if (__DEBUG_BUILD__) {\n      logger.log('[Profiling] Transaction is undefined, skipping profiling');\n    }\n    return transaction;\n  }\n\n  return wrapTransactionWithProfiling(transaction);\n}\n\n/**\n * Wraps startTransaction and stopTransaction with profiling related logic.\n * startProfiling is called after the call to startTransaction in order to avoid our own code from\n * being profiled. Because of that same reason, stopProfiling is called before the call to stopTransaction.\n */\nfunction wrapTransactionWithProfiling(transaction: Transaction): Transaction {\n  // Feature support check first\n  const JSProfilerConstructor = WINDOW.Profiler;\n\n  if (!isJSProfilerSupported(JSProfilerConstructor)) {\n    if (__DEBUG_BUILD__) {\n      logger.log(\n        '[Profiling] Profiling is not supported by this browser, Profiler interface missing on window object.',\n      );\n    }\n    return transaction;\n  }\n\n  // profilesSampleRate is multiplied with tracesSampleRate to get the final sampling rate.\n  if (!transaction.sampled) {\n    if (__DEBUG_BUILD__) {\n      logger.log('[Profiling] Transaction is not sampled, skipping profiling');\n    }\n    return transaction;\n  }\n\n  // If constructor failed once, it will always fail, so we can early return.\n  if (PROFILING_CONSTRUCTOR_FAILED) {\n    if (__DEBUG_BUILD__) {\n      logger.log('[Profiling] Profiling has been disabled for the duration of the current user session.');\n    }\n    return transaction;\n  }\n\n  const client = getCurrentHub().getClient();\n  const options = client && client.getOptions();\n\n  // @ts-ignore not part of the browser options yet\n  const profilesSampleRate = (options && options.profilesSampleRate) || 0;\n  if (profilesSampleRate === undefined) {\n    if (__DEBUG_BUILD__) {\n      logger.log('[Profiling] Profiling disabled, enable it by setting `profilesSampleRate` option to SDK init call.');\n    }\n    return transaction;\n  }\n\n  // Check if we should sample this profile\n  if (Math.random() > profilesSampleRate) {\n    if (__DEBUG_BUILD__) {\n      logger.log('[Profiling] Skip profiling transaction due to sampling.');\n    }\n    return transaction;\n  }\n\n  // From initial testing, it seems that the minimum value for sampleInterval is 10ms.\n  const samplingIntervalMS = 10;\n  // Start the profiler\n  const maxSamples = Math.floor(MAX_PROFILE_DURATION_MS / samplingIntervalMS);\n  let profiler: JSSelfProfiler | undefined;\n\n  // Attempt to initialize the profiler constructor, if it fails, we disable profiling for the current user session.\n  // This is likely due to a missing 'Document-Policy': 'js-profiling' header. We do not want to throw an error if this happens\n  // as we risk breaking the user's application, so just disable profiling and log an error.\n  try {\n    profiler = new JSProfilerConstructor({ sampleInterval: samplingIntervalMS, maxBufferSize: maxSamples });\n  } catch (e) {\n    if (__DEBUG_BUILD__) {\n      logger.log(\n        \"[Profiling] Failed to initialize the Profiling constructor, this is likely due to a missing 'Document-Policy': 'js-profiling' header.\",\n      );\n      logger.log('[Profiling] Disabling profiling for current user session.');\n    }\n    PROFILING_CONSTRUCTOR_FAILED = true;\n  }\n\n  // We failed to construct the profiler, fallback to original transaction - there is no need to log\n  // anything as we already did that in the try/catch block.\n  if (!profiler) {\n    return transaction;\n  }\n\n  if (__DEBUG_BUILD__) {\n    logger.log(`[Profiling] started profiling transaction: ${transaction.name || transaction.description}`);\n  }\n\n  // We create \"unique\" transaction names to avoid concurrent transactions with same names\n  // from being ignored by the profiler. From here on, only this transaction name should be used when\n  // calling the profiler methods. Note: we log the original name to the user to avoid confusion.\n  const profileId = uuid4();\n\n  // A couple of important things to note here:\n  // `CpuProfilerBindings.stopProfiling` will be scheduled to run in 30seconds in order to exceed max profile duration.\n  // Whichever of the two (transaction.finish/timeout) is first to run, the profiling will be stopped and the gathered profile\n  // will be processed when the original transaction is finished. Since onProfileHandler can be invoked multiple times in the\n  // event of an error or user mistake (calling transaction.finish multiple times), it is important that the behavior of onProfileHandler\n  // is idempotent as we do not want any timings or profiles to be overriden by the last call to onProfileHandler.\n  // After the original finish method is called, the event will be reported through the integration and delegated to transport.\n  let processedProfile: ProcessedJSSelfProfile | null = null;\n\n  /**\n   * Idempotent handler for profile stop\n   */\n  function onProfileHandler(): void {\n    // Check if the profile exists and return it the behavior has to be idempotent as users may call transaction.finish multiple times.\n    if (!transaction) {\n      return;\n    }\n    // Satisfy the type checker, but profiler will always be defined here.\n    if (!profiler) {\n      return;\n    }\n    if (processedProfile) {\n      if (__DEBUG_BUILD__) {\n        logger.log(\n          '[Profiling] profile for:',\n          transaction.name || transaction.description,\n          'already exists, returning early',\n        );\n      }\n      return;\n    }\n\n    profiler\n      .stop()\n      .then((p: JSSelfProfile): void => {\n        if (maxDurationTimeoutID) {\n          WINDOW.clearTimeout(maxDurationTimeoutID);\n          maxDurationTimeoutID = undefined;\n        }\n\n        if (__DEBUG_BUILD__) {\n          logger.log(`[Profiling] stopped profiling of transaction: ${transaction.name || transaction.description}`);\n        }\n\n        // In case of an overlapping transaction, stopProfiling may return null and silently ignore the overlapping profile.\n        if (!p) {\n          if (__DEBUG_BUILD__) {\n            logger.log(\n              `[Profiling] profiler returned null profile for: ${transaction.name || transaction.description}`,\n              'this may indicate an overlapping transaction or a call to stopProfiling with a profile title that was never started',\n            );\n          }\n          return;\n        }\n\n        // If a profile has less than 2 samples, it is not useful and should be discarded.\n        if (p.samples.length < 2) {\n          return;\n        }\n\n        processedProfile = { ...p, profile_id: profileId };\n        sendProfile(profileId, processedProfile);\n      })\n      .catch(error => {\n        if (__DEBUG_BUILD__) {\n          logger.log('[Profiling] error while stopping profiler:', error);\n        }\n        return null;\n      });\n  }\n\n  // Enqueue a timeout to prevent profiles from running over max duration.\n  let maxDurationTimeoutID: number | undefined = WINDOW.setTimeout(() => {\n    if (__DEBUG_BUILD__) {\n      logger.log(\n        '[Profiling] max profile duration elapsed, stopping profiling for:',\n        transaction.name || transaction.description,\n      );\n    }\n    void onProfileHandler();\n  }, MAX_PROFILE_DURATION_MS);\n\n  // We need to reference the original finish call to avoid creating an infinite loop\n  const originalFinish = transaction.finish.bind(transaction);\n\n  /**\n   * Wraps startTransaction and stopTransaction with profiling related logic.\n   * startProfiling is called after the call to startTransaction in order to avoid our own code from\n   * being profiled. Because of that same reason, stopProfiling is called before the call to stopTransaction.\n   */\n  function profilingWrappedTransactionFinish(): Promise<Transaction> {\n    if (!transaction) {\n      return originalFinish();\n    }\n    // onProfileHandler should always return the same profile even if this is called multiple times.\n    // Always call onProfileHandler to ensure stopProfiling is called and the timeout is cleared.\n    onProfileHandler();\n\n    // Set profile context\n    transaction.setContext('profile', { profile_id: profileId });\n\n    return originalFinish();\n  }\n\n  transaction.finish = profilingWrappedTransactionFinish;\n  return transaction;\n}\n\n/**\n * Wraps startTransaction with profiling logic. This is done automatically by the profiling integration.\n */\nfunction __PRIVATE__wrapStartTransactionWithProfiling(startTransaction: StartTransaction): StartTransaction {\n  return function wrappedStartTransaction(\n    this: Hub,\n    transactionContext: TransactionContext,\n    customSamplingContext?: CustomSamplingContext,\n  ): Transaction | undefined {\n    const transaction: Transaction | undefined = startTransaction.call(this, transactionContext, customSamplingContext);\n    if (transaction === undefined) {\n      if (__DEBUG_BUILD__) {\n        logger.log('[Profiling] Transaction is undefined, skipping profiling');\n      }\n      return transaction;\n    }\n\n    return wrapTransactionWithProfiling(transaction);\n  };\n}\n\n/**\n * Patches startTransaction and stopTransaction with profiling logic.\n */\nexport function addProfilingExtensionMethods(): void {\n  const carrier = getMainCarrier();\n  if (!carrier.__SENTRY__) {\n    if (__DEBUG_BUILD__) {\n      logger.log(\"[Profiling] Can't find main carrier, profiling won't work.\");\n    }\n    return;\n  }\n  carrier.__SENTRY__.extensions = carrier.__SENTRY__.extensions || {};\n\n  if (!carrier.__SENTRY__.extensions['startTransaction']) {\n    if (__DEBUG_BUILD__) {\n      logger.log(\n        '[Profiling] startTransaction does not exists, profiling will not work. Make sure you import @sentry/tracing package before @sentry/profiling-node as import order matters.',\n      );\n    }\n    return;\n  }\n\n  if (__DEBUG_BUILD__) {\n    logger.log('[Profiling] startTransaction exists, patching it with profiling functionality...');\n  }\n\n  carrier.__SENTRY__.extensions['startTransaction'] = __PRIVATE__wrapStartTransactionWithProfiling(\n    // This is already patched by sentry/tracing, we are going to re-patch it...\n    carrier.__SENTRY__.extensions['startTransaction'] as StartTransaction,\n  );\n}\n"],"names":[],"mappings":"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"}